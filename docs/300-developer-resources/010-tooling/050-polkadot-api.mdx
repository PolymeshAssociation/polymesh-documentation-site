---
title: Direct Chain Interaction with @polkadot/api
description: Guide to using the Polkadot JS API for low-level interaction with the Polymesh blockchain.
id: polkadot-api
slug: /development/tooling/sdk/polkadot-api
sidebar_label: Direct API (@polkadot/api)
tags:
    - polkadot.js
    - api
    - direct interaction
    - low-level
    - types
    - development
    - tooling
---

## Introduction

While the [Polymesh SDK](./) offers high-level abstractions for most development tasks, direct interaction with the Polymesh blockchain is possible using the underlying library: [`@polkadot/api`](https://polkadot.js.org/docs/api/). This library is the primary JavaScript/TypeScript interface for interacting with any Substrate-based chain, including Polymesh.

Using `@polkadot/api` directly provides maximum control and access to the chain's features but requires handling more of the low-level details compared to the Polymesh SDK.

## When to Use `@polkadot/api` Directly

You might consider using `@polkadot/api` directly in specific scenarios:

*   **Bleeding-Edge Features:** Accessing new chain modules or extrinsics immediately after a network upgrade, potentially before they are exposed through the Polymesh SDK.
*   **Specialized Tooling:** Building tools like block explorers, network monitors, or custom scripts that require deep introspection of chain state or specific RPC calls not covered by higher-level abstractions.
*   **Existing Infrastructure:** Integrating Polymesh into systems already built heavily around `@polkadot/api`.
*   **Minimal Dependencies:** When the goal is to have the absolute minimum dependency footprint for simple queries or specific tasks.
*   **Debugging & Learning:** Understanding the underlying mechanics of Polymesh transactions and state by interacting with the base layer directly.

For most application development (dApps, backend services), the **[Polymesh SDK](./)** is the **recommended approach** as it simplifies development, provides helpful abstractions (like Entities and Namespaces), and manages complexities like type conversions and error handling.

## Prerequisites

*   Node.js environment (v18+ recommended)
*   A package manager (npm, yarn, or pnpm)
*   Installation of `@polkadot/api`:
    ```bash
    npm install @polkadot/api
    # or
    yarn add @polkadot/api
    # or
    pnpm add @polkadot/api
    ```
*   **Crucially:** Installation of the correct version of `@polymeshassociation/polymesh-types`. See the [Polymesh Types documentation](./10-sdk/types.mdx) for details.
    ```bash
    npm install @polymeshassociation/polymesh-types@<compatible-version>
    # or
    yarn add @polymeshassociation/polymesh-types@<compatible-version>
    # or
    pnpm add @polymeshassociation/polymesh-types@<compatible-version>
    ```

## The Importance of `polymesh-types`

Polymesh is not a standard Substrate chain; it includes many custom modules, data types, RPC methods, and runtime APIs specific to its domain (regulated assets, identity, compliance, etc.).

The `@polkadot/api` library needs to be explicitly told about these Polymesh-specific definitions to correctly encode arguments for extrinsics and decode data returned from storage or events. This is the primary role of the `@polymeshassociation/polymesh-types` package.

*   **`typesBundle`:** This export from `polymesh-types` provides a comprehensive set of type definitions and overrides required to initialize `@polkadot/api` correctly for Polymesh.
*   **Version Matching:** It is **critical** that the version of `@polymeshassociation/polymesh-types` you install **exactly matches** the runtime specification version of the Polymesh node you are connecting to (e.g., types v7.0.x for a node running chain spec v7.0.x). Mismatches will lead to errors during connection or runtime due to incompatible type definitions.

## Connecting to a Polymesh Node

Here's how to initialize `@polkadot/api` with the necessary Polymesh types:

```typescript title="connectApi.ts"
import { ApiPromise, WsProvider } from '@polkadot/api';
// Import the typesBundle for Polkadot-based chains from polymesh-types
import { typesBundle } from '@polymeshassociation/polymesh-types/bundle/polkadot';

async function connect() {
  // Replace with your node's WebSocket endpoint
  const nodeUrl = 'wss://your-polymesh-node-ws-endpoint';
  const provider = new WsProvider(nodeUrl);

  console.log(`Attempting to connect to ${nodeUrl}`);

  try {
    const api = await ApiPromise.create({
      provider,
      typesBundle, // Essential for Polymesh compatibility!
    });

    await api.isReady;

    console.log(
      `Successfully connected to chain ${api.runtimeChain} using spec ${api.runtimeVersion.specName} v${api.runtimeVersion.specVersion}`
    );

    // You can now use the 'api' object for interactions
    // Example: Get chain properties
    const props = await api.rpc.system.properties();
    console.log(`Token Symbol: ${props.tokenSymbol.unwrapOrDefault().toString()}`);
    console.log(`Token Decimals: ${props.tokenDecimals.unwrapOrDefault().toString()}`);

    await api.disconnect();
  } catch (error) {
    console.error('Connection failed:', error);
    process.exit(1);
  }
}

connect();
```

## Reading Chain Data

Once connected, you can access various chain data points:

*   **Constants:** Values defined in the runtime that rarely change.
    ```typescript
    const existentialDeposit = api.consts.balances.existentialDeposit;
    console.log(`Existential Deposit: ${existentialDeposit.toHuman()}`);
    ```
*   **Storage Queries:** Read data from the chain state. The `polymesh-types` package enables type hinting for Polymesh modules.
    ```typescript
    const someDid = '0x...'; // Replace with an actual DID
    const didRecord = await api.query.identity.didRecords(someDid);

    if (didRecord.isSome) {
      console.log('Primary Key:', didRecord.unwrap().primaryKey.toString());
    } else {
      console.log(`No record found for DID ${someDid}`);
    }

    const ticker = 'MYASSET'; // Replace with an actual ticker
    const assetDetails = await api.query.asset.tokens(ticker);
    console.log(`Asset Details for ${ticker}:`, assetDetails.toHuman());
    ```
*   **RPC Calls:** Execute remote procedure calls exposed by the node.
    ```typescript
    const blockHash = await api.rpc.chain.getBlockHash();
    console.log(`Latest block hash: ${blockHash.toHex()}`);

    const peers = await api.rpc.system.peers();
    console.log(`Connected peers: ${peers.length}`);
    ```

## Submitting Transactions

Submitting transactions involves creating an extrinsic object and then signing and sending it.

```typescript title="submitTx.ts"
import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';
import { typesBundle } from '@polymeshassociation/polymesh-types/bundle/polkadot';
import { ISubmittableResult } from '@polkadot/types/types';

async function submitTransfer(api: ApiPromise) {
  // WARNING: Using keyring with hardcoded mnemonics is insecure and for DEVELOPMENT ONLY.
  // Use secure signing methods (e.g., browser extension, Vault) for production.
  const keyring = new Keyring({ type: 'sr25519' });
  const alice = keyring.addFromUri('//Alice'); // Ensure Alice has funds and a DID on dev chain
  const bobAddress = '5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty'; // Example Bob address

  console.log(`Transferring 10 POLYX from ${alice.address} to ${bobAddress}`);

  try {
    // 1. Build the extrinsic
    const transferExtrinsic = api.tx.balances.transferWithMemo(bobAddress, 10 * 10 ** 6, 'Direct API Test'); // Amount in Plancks (assuming 6 decimals)

    // 2. Sign and send
    const unsub = await transferExtrinsic.signAndSend(alice, (result: ISubmittableResult) => {
      console.log(`Current status is ${result.status.type}`);

      if (result.status.isInBlock) {
        console.log(`Transaction included at block hash ${result.status.asInBlock}`);
      } else if (result.status.isFinalized) {
        console.log(`Transaction finalized at block hash ${result.status.asFinalized}`);

        // Check for errors in events
        result.events.forEach(({ event: { data, method, section } }) => {
          if (section === 'system' && method === 'ExtrinsicFailed') {
            const [dispatchError] = data as any; // Adjust type based on polkadot-js version
            let errorInfo = dispatchError.toString();
            if (dispatchError.isModule) {
               const decoded = api.registry.findMetaError(dispatchError.asModule);
               const { docs, name, section } = decoded;
               errorInfo = `${section}.${name}: ${docs.join(' ')}`;
            }
            console.error(`Error in transaction: ${errorInfo}`);
          }
        });

        unsub(); // Unsubscribe once finalized
      } else if (result.isError) {
        console.error(`Transaction error`);
        unsub();
      }
    });
  } catch (error) {
    console.error('Failed to send transaction:', error);
  }

  // Keep the process running briefly to see finalization, or handle disconnection elsewhere
   // await new Promise(resolve => setTimeout(resolve, 60000)); // Wait 60s
   // await api.disconnect(); // Disconnect after example finishes if needed
}

async function main() {
    const provider = new WsProvider('wss://your-polymesh-node-ws-endpoint'); // Replace
    const api = await ApiPromise.create({ provider, typesBundle });
    await api.isReady;
    await submitTransfer(api);
    // Ensure script doesn't exit immediately if waiting for finalization
    // You might need better async handling in a real app
}

// main().catch(console.error); // Add proper execution context
```

*   **Signing:** The example uses `@polkadot/keyring` for simplicity. **Never use hardcoded mnemonics in production.** For secure signing, refer to the [Signing Managers](./10-sdk/signing.mdx) page, especially the section on [Offline Signing](./10-sdk/signing.mdx#offline-signing). You would typically use `.toSignablePayload()` to generate the data, sign it externally, and then submit using `api.rpc.author.submitExtrinsic()` or a similar method depending on your signer integration.
*   **Callback/Status:** The `signAndSend` method takes a callback that receives status updates (`ISubmittableResult`). You track the transaction through phases like `isInBlock` and `isFinalized`. Critically, check `result.events` for `system.ExtrinsicFailed` upon finalization to detect on-chain errors.

## Key Considerations

*   **Error Handling:** Direct interaction requires careful checking of `dispatchError` within the transaction events upon finalization. Errors aren't automatically converted into user-friendly exceptions as in the SDK.
*   **Polymesh Business Logic:** All native Polymesh rules (identity requirements, compliance, asset states) still apply. `@polkadot/api` sends the extrinsic, but the chain validates it. You need to ensure prerequisites are met.
*   **Type Safety:** Relies heavily on the correctness and version matching of the `polymesh-types` package.
*   **Updates & Maintenance:** When the Polymesh chain upgrades, especially with breaking changes, you'll need to update `@polkadot/api` and `@polymeshassociation/polymesh-types` accordingly and potentially adjust your code if underlying types or extrinsic signatures change. The Polymesh SDK aims to provide a more stable interface across upgrades.

## Comparison: SDK vs. Direct `@polkadot/api`

| Feature         | Polymesh SDK (`@polymeshassociation/polymesh-sdk`) | Direct `@polkadot/api` + `polymesh-types` |
| :-------------- | :------------------------------------------------- | :---------------------------------------- |
| **Abstraction** | High (Entities, Namespaces, Procedures)            | Low (Direct extrinsics, storage, RPC)     |
| **Ease of Use** | Higher                                             | Lower                                     |
| **Type Safety** | Strong (via internal types)                        | Strong (requires correct `typesBundle`)   |
| **Flexibility** | Good (covers most common use cases)              | Maximum (access to all chain features)    |
| **Maintenance** | Lower (SDK handles many breaking changes)          | Higher (sensitive to chain upgrades)      |
| **Error Handling**| Simplified (throws specific `PolymeshError`s)    | Manual (requires checking `dispatchError`) |
| **Dependencies**| Higher                                             | Lower                                     |
| **Recommended For** | Application Development, dApps, Integrations   | Low-level tooling, Debugging, Edge Cases  |

**Recommendation:** Use the Polymesh SDK for most development tasks. Use `@polkadot/api` directly only when the SDK's abstractions don't meet your specific low-level requirements.

## Further Resources

*   **`@polkadot/api` Documentation:** [`https://polkadot.js.org/docs/api/`](https://polkadot.js.org/docs/api/)
*   **`@polymeshassociation/polymesh-types`:** [GitHub Repo](https://github.com/PolymeshAssociation/polymesh-types) | [Types Doc](./10-sdk/types.mdx)
*   **Polymesh SDK:** [Main Doc](./) | [Signing Managers](./10-sdk/signing.mdx)