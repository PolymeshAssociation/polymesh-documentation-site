---
title: Confidential Assets Architecture
description: Architectural design and components of Polymesh Confidential Assets
sidebar_label: Architecture
slug: /confidential-assets/architecture
id: confidential-assets-architecture
---

# Confidential Assets Architecture

This page provides an architectural overview of Polymesh Confidential Assets (PCA), explaining the core design principles, system components, and how they work together to enable privacy-preserving transfers with regulatory compliance.

Polymesh Confidential Assets implement a sophisticated protocol for privacy-preserving asset transfers on Polymesh. The implementation uses account-based confidential state with zero-knowledge proofs, enabling fully anonymous transfers while supporting the multi-party settlement workflows required for regulated securities.

## Core Architectural Principles

The architecture is engineered around several non-negotiable principles that guide every design decision:

### 1. Full Anonymity with Constant Complexity

The architecture achieves full confidentiality while maintaining efficient on-chain operations:

- **Full anonymity**: Balances, transaction values, asset types, and participant identities remain private
- **Global anonymity set**: Any transaction's anonymity encompasses all accounts in the system
- **Constant-size proofs**: On-chain proof size is O(1) regardless of anonymity set size

This design resolves the limitation of many account-based privacy systems where transaction size grows with the anonymity parameter.

### 2. Non-Interactivity and Concurrency Handling

The architecture enables:

- **Non-interactive transfers**: Senders can initiate transfers to offline receivers
- **Concurrency resolution**: Circumvents the problem where incoming transactions invalidate pending outgoing proofs—a common issue in account-based anonymous systems

The pending counter mechanism allows multiple in-flight transactions without state conflicts.

### 3. Account-Based Model with Asset-Specific Accounts

The architecture uses an account-based model for confidential state:

- **Account-based state**: More intuitive "table of balances" representation compared to UTXO models
- **Asset-specific accounts**: Each account holds one asset type, so proving work scales with the specific asset being transacted, not all assets held

This simplifies operations like Proof of Balance while maintaining privacy guarantees.

### 4. Regulatory Compliance by Design

Privacy and compliance are not in conflict but architected together:

- **Scoped visibility**: Asset issuers designate auditors/mediators with asset-specific decryption capabilities
- **Dual compliance model**: Retrospective audit access (auditors) and prospective control (mediators)
- **Receiver affirmation**: Explicit accept/reject authority prevents forced asset delivery, aligning with securities regulations

## System Architecture

The key architectural theme is **off-chain proof generation** with **on-chain verification and state transitions**. This separation enables privacy while maintaining public verifiability.

## System Components

```mermaid
%%{init: {"flowchart": {"curve": "linear", "nodeSpacing": 40, "rankSpacing": 55}}}%%
flowchart TB
    subgraph "User Systems"
        WALLET["Wallet / Client"]
        PROVER["Proof Generation Service<br/>(off-chain)"]
        WALLET --> PROVER
    end

    subgraph "Polymesh Chain"
        VERIFY["Proof Verification<br/>(on-chain)"]
        CURVE["Curve Trees<br/>(account/asset roots)"]
        SETTLEMENT["Confidential Settlement<br/>state machine"]
        LEGS["Encrypted Settlement Legs"]
        CURVE --> VERIFY
        LEGS --> SETTLEMENT
    end

    subgraph "Compliance"
        AUDITOR["Auditors<br/>(retrospective access)"]
        MEDIATOR["Mediators<br/>(prospective control)"]
    end

    PROVER -->|Proofs| VERIFY
    WALLET -->|Txs| SETTLEMENT

    %% Keep labels short to avoid clipping; attach as dotted annotations.
    AUDITOR --> LEGS
    MEDIATOR --> LEGS
    MEDIATOR --> SETTLEMENT
    AUDITOR -. "Decrypt legs" .-> LEGS
    MEDIATOR -. "Decrypt legs" .-> LEGS
    MEDIATOR -. "Affirm or reject" .-> SETTLEMENT
```

### Component Roles

**User Systems:**

- **Wallet/Client**: Manages user keys, account state, and transaction coordination
- **Proof Generation Service**: Computationally intensive ZK proof generation happens off-chain (e.g., WASM library, proof server or remote service)

**Polymesh Chain:**

- **Proof Verification**: Validators verify ZK proofs without learning private values—cryptographic guarantees ensure correctness
- **Curve Trees**: Accumulators that compactly represent valid account/asset states as roots; membership proofs demonstrate state validity without revealing which specific account
- **Settlement State Machine**: Manages the multi-party affirmation lifecycle for transfers
- **Encrypted Legs**: Store transfer details encrypted for designated parties (sender, receiver, auditors, mediators)

**Compliance Layer:**

- **Auditors**: Passive entities with decryption keys for asset-specific legs; enable retrospective compliance checks without gating transactions
- **Mediators**: Active participants who can decrypt and must affirm or reject settlements when required; provide prospective regulatory control

### Privacy and Verification Separation

This architecture achieves privacy through strategic separation:

1. **What chain validators verify**: Proof validity, nullifier uniqueness, accumulator membership, sufficient balance (cryptographically hidden)
2. **What chain validators never learn**: Specific account identities, transaction amounts, asset types, sender/receiver linkage
3. **What compliance sees**: Only asset-specific legs they're authorized for, through encrypted payloads

The curve-tree roots act as a "compressed representation" of all valid account states—validators can verify state transitions against these roots without examining individual account details.

## Confidential Account Structure

A single key pair can register many assets, but each asset gets its own on-chain confidential account state. Think of the key as the identity, and each asset registration as a separate state commitment. This keeps ZK proving scoped to the asset being transacted instead of growing with every asset the key controls.

### Private State (known only to account holder)

These components are never revealed on-chain:

- **Finalized balance** – The spendable amount for the asset
- **Pending counter** – Tracks in-flight transactions awaiting receiver claim; enables concurrent operations and Proof of Balance
- **Account key** – Used to generate zero-knowledge proofs for state transitions
- **Encryption key** – Used to encrypt/decrypt settlement leg payloads
- **Randomness** – Secret values that derive commitments and nullifiers

### Public State (published on-chain)

These components are visible to validators but don't reveal the private state:

- **State commitment** – Cryptographic commitment to the private state, stored in the curve tree accumulator
- **Nullifier** – Emitted when spending an old account state; prevents double-spending without revealing which account was updated

### Cryptographic Relationships

- **State commitment**: Derived from the previous account state (balance/counter/asset data) blinded with Pseudorandom Function(PRF) derived randomness; published to the curve tree accumulator.
- **Nullifier**: Derived from the previous state using deterministic randomness (PRF over secret key + counter) so the old state cannot be spent twice.
- **Deterministic recovery**: Because the randomness is derived (not purely random), a user can recompute commitments/nullifiers from historical data with their secret key, enabling state recovery if local state is lost.

:::info

Pseudorandom Function (PRF): a deterministic function keyed by the confidential account secret key that outputs values indistinguishable from random; used here to derive per-state randomness.

:::

### Asset-Specific Design

The architecture uses **asset-specific accounts** rather than multi-asset accounts. This design choice has important implications:

- **Scalable proving**: Proof generation complexity scales with the specific asset being transacted, not all assets held
- **Asset privacy**: The asset type itself is hidden within the anonymity set
- **Simplified state management**: Each account-asset pair has independent state, reducing complexity

Users may have multiple confidential accounts for different assets, but each account-asset relationship has its own balance, counter, and state commitment.

## Settlement Overview

The settlement lifecycle, roles, and proofs are documented in [Settlement Workflow](/confidential-assets/settlement-workflow). Refer there for detailed mechanics; this page focuses on architectural components and cryptographic structure.

## Proof of Balance (PoB)

For PoB mechanics, trade‑offs (auditor‑assisted vs. generic), and counter‑update transactions, see [Compliance & Regulation](/confidential-assets/compliance-and-regulation) and [Settlement Workflow](/confidential-assets/settlement-workflow).

## Compliance Hooks

Details on auditors, mediators, key privacy, and policy gating live in [Compliance & Regulation](/confidential-assets/compliance-and-regulation). This architecture page references those hooks but avoids duplicating process specifics.

## Architectural Significance

Polymesh Confidential Assets resolve a fundamental tension in blockchain-based asset systems: the need for transactional privacy versus regulatory compliance. The architecture achieves this through:

1. **Privacy by design**: Full anonymity with constant-size proofs integrated at the protocol level
2. **Compliance by design**: Scoped access and control points built into the settlement workflow
3. **Practical settlement**: Multi-party affirmation workflows matching real-world securities processes
4. **Scalable proof system**: Computational work scales with specific transactions, not global state

This architectural foundation enables tokenization of regulated assets while maintaining the privacy properties required for financial markets.
