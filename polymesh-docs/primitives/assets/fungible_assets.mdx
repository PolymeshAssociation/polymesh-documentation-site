---
title: Fungible Assets
sidebar_position: 1
description: ''
# slug: /polymesh-docs/primitives/assets
subsite: polymesh-docs
---

## Overview

Fungible assets on Polymesh can represent any type of digitalised asset, and are originated and managed through the asset primitives implemented in the base layer logic in Polymesh.

This ensures that all assets are created in a standardised manner, allowing related functionality such as corporate actions, settlement and compliance, to function seamlessly across all assets.

Once an asset has been created, its ownership is represented via balances of that assets tokens held by different investors.

Ownership of an asset on Polymesh can be determined via its:

- total supply: the total number of tokens that represent ownership in the asset
- investor balances: the individual balance of each investing identity in the asset

The asset pallet documentation can be found at:
https://docs.polymesh.live/pallet_asset/index.html

Polymesh allows you to manage the full lifecycle of any asset directly on the Polymesh blockchain, including the issuance, initial distribution or fund-raise of the asset and any subsequent corporate actions such as dividend payments, capital distributions or corporate ballots.

Asset tokens can be either divisible or indivisible.

## Asset Creation

Users can create their asset, specifying the type of the asset (e.g. Equity, Bond, Fund). On creation, Polymesh will assign a unique system-generated Asset ID for the newly created asset.

The asset is initially created with a zero total supply. For the initial issuance of the asset, see the [Issuance section](#issuance).

As well as being identified via a unique Asset ID, assets can be associated with a unique ticker and additional external identifiers, such as ISINs, CUSIPs, CINs, LEIs and DTIs, with Polymesh validating that these identifiers are consistent (i.e. that their checksums match).

### Process

Once an asset issuer has created and configured their asset, they can then issue tokens representing ownership in the asset to themselves or a distribution external agent of the asset.

The agent can then distribute those asset tokens to investors directly or via a security token offering, in both cases using the settlement engine.

This approach allows a clean separation between the issuance process, which bypasses both the compliance and settlement engine and is restricted to only issuance to the configured agents, and the distribution process which uses both the compliance and settlement engines.

## Checkpoints

An _asset checkpoint_ is a collection of records representing the balances of that asset at a given time. The balances recorded are the total asset balance and all the balances held by identities.

This is useful for capital distributions and corporate ballots where we need a consistent set of balances as of some specific time (or block).

### Creating a checkpoint

There are two ways to create a checkpoint.

1. Call the dispatchable `create_checkpoint(assetId)` in the `checkpoint` pallet. This creates a checkpoint for the asset of `AssetId`. The total balance is recorded instantly, and each balance held by an identity is recorded just before the next transaction to or from that identity. Since the balances of identities are not recorded instantly, we call this process _lazy checkpointing_. A consequence of this method is that no records are made if there are no transactions.

2. Create a checkpoint schedule using the dispatchable `create_schedule(assetId, schedule)` in the same pallet. A schedule consists of a set of `Moment` values. Scheduled checkpoints are created automatically at times defined by the schedule but are otherwise identical in nature to manual checkpoints. Scheduling of the next checkpoint happens lazily as well, on an asset transaction or minting. If there are no such transactions by the time a checkpoint is due, it does not get rescheduled, which is fine with the scheduler since it takes into account any missed checkpoints.

### Accessing an existing checkpoint

The checkpoints of an asset form a sequence that is indexed starting from 1. The total balance and balances of identities are stored at these indices.

To read the total supply of `assetId` at checkpoint index `i` one calls the getter `total_supply_at(assetId, i)` in the `asset` pallet. The getter returns the value directly from runtime storage.

To read the checkpoint balance of `identity` one calls the function `get_balance_at(assetId, identity, i)` in the same pallet. This function returns the checkpoint balance at `i` by searching for the least checkpoint index greater or equal to `i` or, if no such record exists due to the absence of transactions, the current asset balance of `identity`.

The time at which a checkpoint was made is stored in a map indexed by checkpoint sequence numbers and can be read knowing the required sequence number.

[unix_time]: https://en.wikipedia.org/wiki/Unix_time
