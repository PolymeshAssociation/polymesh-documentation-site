"use strict";(globalThis.webpackChunkpolymesh_developer_documentation=globalThis.webpackChunkpolymesh_developer_documentation||[]).push([[51246],{28453(e,n,i){i.d(n,{R:()=>c,x:()=>r});var s=i(96540);const t={},o=s.createContext(t);function c(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(o.Provider,{value:n},e.children)}},97716(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"developer-resources/tooling/sdk/polkadot-api-events","title":"Subscribing to Chain Events with @polkadot/api","description":"Guide to using the Polkadot JS API via the Polymesh SDK to subscribe to and process blockchain events.","source":"@site/docs/300-developer-resources/010-tooling/10-sdk/030-event-subscription-polkadot.mdx","sourceDirName":"300-developer-resources/010-tooling/10-sdk","slug":"/development/tooling/sdk/polkadot-api-events","permalink":"/polymesh-documentation-site/development/tooling/sdk/polkadot-api-events","draft":false,"unlisted":false,"editUrl":"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/docs/300-developer-resources/010-tooling/10-sdk/030-event-subscription-polkadot.mdx","tags":[{"inline":true,"label":"polkadot.js","permalink":"/polymesh-documentation-site/tags/polkadot-js"},{"inline":true,"label":"api","permalink":"/polymesh-documentation-site/tags/api"},{"inline":true,"label":"events","permalink":"/polymesh-documentation-site/tags/events"},{"inline":true,"label":"subscription","permalink":"/polymesh-documentation-site/tags/subscription"},{"inline":true,"label":"sdk","permalink":"/polymesh-documentation-site/tags/sdk"},{"inline":true,"label":"development","permalink":"/polymesh-documentation-site/tags/development"},{"inline":true,"label":"tooling","permalink":"/polymesh-documentation-site/tags/tooling"}],"version":"current","sidebarPosition":30,"frontMatter":{"title":"Subscribing to Chain Events with @polkadot/api","description":"Guide to using the Polkadot JS API via the Polymesh SDK to subscribe to and process blockchain events.","id":"polkadot-api-events","slug":"/development/tooling/sdk/polkadot-api-events","sidebar_label":"Chain Event Subscription (@polkadot/api)","tags":["polkadot.js","api","events","subscription","sdk","development","tooling"]},"sidebar":"docs","previous":{"title":"Signing Managers","permalink":"/polymesh-documentation-site/development/tooling/sdk/signing"},"next":{"title":"Local Dev Environment","permalink":"/polymesh-documentation-site/development/tooling/local-setup"}}');var t=i(74848),o=i(28453);const c={title:"Subscribing to Chain Events with @polkadot/api",description:"Guide to using the Polkadot JS API via the Polymesh SDK to subscribe to and process blockchain events.",id:"polkadot-api-events",slug:"/development/tooling/sdk/polkadot-api-events",sidebar_label:"Chain Event Subscription (@polkadot/api)",tags:["polkadot.js","api","events","subscription","sdk","development","tooling"]},r=void 0,a={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Use Case: Monitoring POLYX Transfers",id:"use-case-monitoring-polyx-transfers",level:2},{value:"Example Script Breakdown",id:"example-script-breakdown",level:2},{value:"1. Imports and Setup",id:"1-imports-and-setup",level:3},{value:"2. Connecting and Accessing the API",id:"2-connecting-and-accessing-the-api",level:3},{value:"3. Subscribing to Finalized Blocks",id:"3-subscribing-to-finalized-blocks",level:3},{value:"4. Processing Block Events (<code>processBlockEvents</code>)",id:"4-processing-block-events-processblockevents",level:3},{value:"5. Extracting Event and Extrinsic Details",id:"5-extracting-event-and-extrinsic-details",level:3},{value:"6. Handling a Specific Event Type (<code>balances.Transfer</code>)",id:"6-handling-a-specific-event-type-balancestransfer",level:3},{value:"7. Error Handling and Cleanup",id:"7-error-handling-and-cleanup",level:3},{value:"Full Example Script",id:"full-example-script",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["While the ",(0,t.jsx)(n.a,{href:"./",children:"Polymesh SDK"})," provides high-level abstractions for most common blockchain interactions, there are scenarios where you might need lower-level access, particularly for listening to real-time events occurring on the chain. A prime example is subscribing to new blocks and processing the events they contain."]}),"\n",(0,t.jsxs)(n.p,{children:["This guide demonstrates how to access the underlying ",(0,t.jsx)(n.a,{href:"https://polkadot.js.org/docs/api/",children:(0,t.jsx)(n.code,{children:"@polkadot/api"})})," instance, managed by the Polymesh SDK, to subscribe to finalized blocks and process specific events like POLYX transfers. Using the SDK's ",(0,t.jsx)(n.code,{children:"@polkadot/api"})," instance ensures you have the correct Polymesh-specific type definitions, simplifying development and enhancing type safety."]}),"\n",(0,t.jsx)(n.admonition,{title:"Internal SDK Property",type:"warning",children:(0,t.jsxs)(n.p,{children:["Accessing the ",(0,t.jsx)(n.code,{children:"@polkadot/api"})," instance via ",(0,t.jsx)(n.code,{children:"sdk._polkadotApi"})," uses an internal property of the SDK. While currently the standard way to achieve this for advanced use cases, be aware that internal details might change in future SDK versions. For most application logic, prefer the stable, high-level SDK methods."]})}),"\n",(0,t.jsx)(n.h2,{id:"use-case-monitoring-polyx-transfers",children:"Use Case: Monitoring POLYX Transfers"}),"\n",(0,t.jsx)(n.p,{children:"Imagine you need to build a service that monitors all POLYX transfers happening on the Polymesh network in real-time. This could be for analytics, notifications, or triggering other off-chain actions. The most efficient way to do this is by subscribing to finalized blocks and inspecting their events."}),"\n",(0,t.jsx)(n.h2,{id:"example-script-breakdown",children:"Example Script Breakdown"}),"\n",(0,t.jsxs)(n.p,{children:["The following sections break down a TypeScript script that connects to Polymesh via the SDK, accesses the underlying ",(0,t.jsx)(n.code,{children:"@polkadot/api"}),", subscribes to finalized blocks, and logs details for any ",(0,t.jsx)(n.code,{children:"balances.Transfer"})," events found."]}),"\n",(0,t.jsx)(n.h3,{id:"1-imports-and-setup",children:"1. Imports and Setup"}),"\n",(0,t.jsx)(n.p,{children:"First, we import necessary components from the SDK and its utilities:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Polymesh } from '@polymeshassociation/polymesh-sdk';\nimport { UnsubCallback } from '@polymeshassociation/polymesh-sdk/types';\nimport {\n  balanceToBigNumber,\n  instructionMemoToString,\n} from '@polymeshassociation/polymesh-sdk/utils/conversion';\n\n// Node URL and global variables for SDK and API instances\nconst nodeUrl = 'ws://localhost:9944'; // Use your node's WebSocket endpoint\nlet sdk: Polymesh | null = null;\nlet api: Polymesh['_polkadotApi'] | null = null;\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Polymesh"}),": The main SDK entry point."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"UnsubCallback"}),": The type for the function returned when creating a subscription, used to unsubscribe later."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"balanceToBigNumber"}),", ",(0,t.jsx)(n.code,{children:"instructionMemoToString"}),": Utility functions from the SDK to convert chain data types (like ",(0,t.jsx)(n.code,{children:"Balance"})," or ",(0,t.jsx)(n.code,{children:"Memo"}),") into more usable formats (like ",(0,t.jsx)(n.code,{children:"BigNumber"})," or ",(0,t.jsx)(n.code,{children:"string"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["We define the ",(0,t.jsx)(n.code,{children:"nodeUrl"})," and initialize ",(0,t.jsx)(n.code,{children:"sdk"})," and ",(0,t.jsx)(n.code,{children:"api"})," variables."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-connecting-and-accessing-the-api",children:"2. Connecting and Accessing the API"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"main"})," function handles the connection and subscription setup:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const main = async () => {\n  let unsubscribeFinalizedHeads: UnsubCallback | undefined;\n  try {\n    console.log('Connecting to Polymesh');\n\n    // Connect to the Polymesh blockchain using the SDK\n    sdk = await Polymesh.connect({\n      nodeUrl,\n      // Optional: suppress initialization warnings if needed\n      polkadot: { noInitWarn: true },\n    });\n\n    // Access the underlying @polkadot/api instance\n    // eslint-disable-next-line no-underscore-dangle\n    api = sdk._polkadotApi;\n\n    // Retrieve network properties to confirm a successful connection\n    const networkProps = await sdk.network.getNetworkProperties();\n    console.log(\n      'Successfully connected to',\n      networkProps.name,\n      'Spec version:',\n      networkProps.version.toString(),\n    );\n\n    // ... subscription logic comes next ...\n\n  } catch (error) {\n    console.error('Error:', error);\n    if (unsubscribeFinalizedHeads) {\n      unsubscribeFinalizedHeads(); // Clean up subscription on error\n    }\n    process.exit(1);\n  }\n};\n\nmain();\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We connect using ",(0,t.jsx)(n.code,{children:"Polymesh.connect"}),", passing the node URL."]}),"\n",(0,t.jsxs)(n.li,{children:["Crucially, we obtain the ",(0,t.jsx)(n.code,{children:"@polkadot/api"})," instance using ",(0,t.jsx)(n.code,{children:"sdk._polkadotApi"}),". This instance is already configured with all Polymesh-specific types."]}),"\n",(0,t.jsxs)(n.li,{children:["We fetch network properties using the SDK's ",(0,t.jsx)(n.code,{children:"network.getNetworkProperties()"})," method to verify the connection."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-subscribing-to-finalized-blocks",children:"3. Subscribing to Finalized Blocks"}),"\n",(0,t.jsxs)(n.p,{children:["We use the accessed ",(0,t.jsx)(n.code,{children:"api"})," object to subscribe to finalized block headers:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"    // Inside the main function's try block:\n    unsubscribeFinalizedHeads = await api.rpc.chain.subscribeFinalizedHeads(\n      async (header) => {\n        // Callback function triggered for each finalized block\n        if (!api) throw new Error('API not initialized'); // Type guard\n        const blockHash = header.hash.toString();\n\n        // Process events within this block\n        await processBlockEvents(blockHash);\n      },\n    );\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"api.rpc.chain.subscribeFinalizedHeads"})," establishes a WebSocket subscription."]}),"\n",(0,t.jsx)(n.li,{children:"It takes a callback function that executes every time a new block is finalized."}),"\n",(0,t.jsxs)(n.li,{children:["The callback receives the block ",(0,t.jsx)(n.code,{children:"header"}),". We extract the ",(0,t.jsx)(n.code,{children:"blockHash"})," from it."]}),"\n",(0,t.jsxs)(n.li,{children:["We call a separate function, ",(0,t.jsx)(n.code,{children:"processBlockEvents"}),", to handle the logic for fetching and parsing events for that specific block."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"subscribeFinalizedHeads"})," method returns an ",(0,t.jsx)(n.code,{children:"UnsubCallback"})," function, which we store in ",(0,t.jsx)(n.code,{children:"unsubscribeFinalizedHeads"})," to allow us to stop the subscription later."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"4-processing-block-events-processblockevents",children:["4. Processing Block Events (",(0,t.jsx)(n.code,{children:"processBlockEvents"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["This asynchronous function takes a ",(0,t.jsx)(n.code,{children:"blockHash"})," and processes all events within that block:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"/**\n * Processes block events and handles Transfer events.\n * @param hash The block hash for the finalized block.\n */\nasync function processBlockEvents(hash: string): Promise<void> {\n  if (!api) throw new Error('API not initialized'); // Type guard\n\n  // 1. Get the full block data\n  const finalizedBlock = await api.rpc.chain.getBlock(hash);\n  const blockNumber = finalizedBlock.block.header.number.unwrap().toString();\n  const { extrinsics } = finalizedBlock.block; // Get extrinsics in the block\n  console.log(`Processing Block number ${blockNumber}`);\n\n  // 2. Get API instance at the specific block's state\n  const apiAtBlock = await api.at(hash);\n\n  // 3. Query all system events for this block\n  const events = await apiAtBlock.query.system.events();\n\n  // 4. Iterate through each event record\n  events.forEach((record) => {\n    // ... event processing logic ...\n  });\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Get Block Data:"})," We fetch the full block using ",(0,t.jsx)(n.code,{children:"api.rpc.chain.getBlock(hash)"}),". This gives us access to the block header (for the number) and the list of extrinsics included in the block."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"API at Block State:"})," We get a specific instance of the API pinned to the state of the chain ",(0,t.jsx)(n.em,{children:"at that block hash"})," using ",(0,t.jsx)(n.code,{children:"api.at(hash)"}),". This is essential because chain state can change between blocks, and querying events requires looking at the state corresponding to the block they occurred in."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Query Events:"})," We use the block-specific API instance (",(0,t.jsx)(n.code,{children:"apiAtBlock"}),") to query all events recorded for that block via ",(0,t.jsx)(n.code,{children:"apiAtBlock.query.system.events()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Iterate Events:"})," We loop through the array of event records."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"5-extracting-event-and-extrinsic-details",children:"5. Extracting Event and Extrinsic Details"}),"\n",(0,t.jsxs)(n.p,{children:["Inside the ",(0,t.jsx)(n.code,{children:"forEach"})," loop, we extract information about each event and, if applicable, the extrinsic that triggered it:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"    // Inside the events.forEach loop:\n    if (!api) throw new Error('API not initialized'); // Type guard needed inside loop too\n    const { event, phase } = record;\n    let extrinsicHash: string | undefined;\n    let extrinsicId: number | undefined;\n    let method: string | undefined;\n    let section: string | undefined;\n\n    // Check if the event was emitted during an extrinsic's execution phase\n    if (phase.isApplyExtrinsic) {\n      extrinsicId = phase.asApplyExtrinsic.toNumber();\n      // Get the corresponding extrinsic from the block's list\n      const extrinsic = extrinsics[extrinsicId];\n      extrinsicHash = extrinsic.hash.toString();\n      method = extrinsic.method.method; // e.g., 'transferWithMemo'\n      section = extrinsic.method.section; // e.g., 'balances'\n    }\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Each ",(0,t.jsx)(n.code,{children:"record"})," contains the ",(0,t.jsx)(n.code,{children:"event"})," itself and the ",(0,t.jsx)(n.code,{children:"phase"})," during which it occurred."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"phase"})," tells us if the event happened during the application of an extrinsic (",(0,t.jsx)(n.code,{children:"phase.isApplyExtrinsic"}),"). If so, we can get the index (",(0,t.jsx)(n.code,{children:"extrinsicId"}),") of that extrinsic within the block's list."]}),"\n",(0,t.jsxs)(n.li,{children:["We use the ",(0,t.jsx)(n.code,{children:"extrinsicId"})," to look up the actual extrinsic object from the ",(0,t.jsx)(n.code,{children:"extrinsics"})," array obtained earlier."]}),"\n",(0,t.jsxs)(n.li,{children:["From the extrinsic, we can get its ",(0,t.jsx)(n.code,{children:"hash"}),", ",(0,t.jsx)(n.code,{children:"method"})," (the function name), and ",(0,t.jsx)(n.code,{children:"section"})," (the pallet/module name)."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"6-handling-a-specific-event-type-balancestransfer",children:["6. Handling a Specific Event Type (",(0,t.jsx)(n.code,{children:"balances.Transfer"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["Now, we check if the current ",(0,t.jsx)(n.code,{children:"event"})," is the one we're interested in \u2013 ",(0,t.jsx)(n.code,{children:"balances.Transfer"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"    // Inside the events.forEach loop, after extracting phase info:\n\n    // Check if the event is a Balances.Transfer event\n    if (api.events.balances.Transfer.is(event)) {\n      // Extract data specific to the Transfer event\n      const balancesEvent = event.data;\n      const fromDid = balancesEvent[0].unwrapOrDefault().toString();\n      const fromAddress = balancesEvent[1].toString();\n      const toDid = balancesEvent[2].unwrapOrDefault().toString();\n      const toAddress = balancesEvent[3].toString();\n      const amount = balanceToBigNumber(balancesEvent[4]).toString();\n      const memo = balancesEvent[5].isSome\n        ? instructionMemoToString(balancesEvent[5].unwrap())\n        : undefined;\n\n      // Log the details\n      console.log(\n        'Transfer event details:',\n        // Event-specific data:\n        { fromDid, fromAddress, toDid, toAddress, amount, memo },\n        // Contextual data:\n        { blockNumber, extrinsicId, extrinsicHash, section, method },\n      );\n    }\n\n    // ... could add else if blocks here to handle other event types ...\n  }); // End of events.forEach\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Check:"})," ",(0,t.jsx)(n.code,{children:"api.events.balances.Transfer.is(event)"})," is a type guard provided by ",(0,t.jsx)(n.code,{children:"@polkadot/api"})," (aware of Polymesh types via the SDK's setup). It safely checks if the generic ",(0,t.jsx)(n.code,{children:"event"})," object is specifically a ",(0,t.jsx)(n.code,{children:"balances.Transfer"})," event."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Extraction:"})," If it is a ",(0,t.jsx)(n.code,{children:"balances.Transfer"})," event, we access its specific payload via ",(0,t.jsx)(n.code,{children:"event.data"}),". The indices (",(0,t.jsx)(n.code,{children:"balancesEvent[0]"}),", ",(0,t.jsx)(n.code,{children:"balancesEvent[1]"}),", etc.) correspond to the fields defined for the ",(0,t.jsx)(n.code,{children:"Transfer"})," event in the Polymesh runtime:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[0]"}),": ",(0,t.jsx)(n.code,{children:"Option<IdentityId>"})," (Sender DID)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[1]"}),": ",(0,t.jsx)(n.code,{children:"AccountId"})," (Sender Address)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[2]"}),": ",(0,t.jsx)(n.code,{children:"Option<IdentityId>"})," (Receiver DID)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[3]"}),": ",(0,t.jsx)(n.code,{children:"AccountId"})," (Receiver Address)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[4]"}),": ",(0,t.jsx)(n.code,{children:"Balance"})," (Amount transferred)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[5]"}),": ",(0,t.jsx)(n.code,{children:"Option<Memo>"})," (Optional memo)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Conversion:"})," We use ",(0,t.jsx)(n.code,{children:".toString()"})," for addresses and DIDs. For complex types like ",(0,t.jsx)(n.code,{children:"Balance"})," and ",(0,t.jsx)(n.code,{children:"Memo"}),", we use the SDK's utility functions (",(0,t.jsx)(n.code,{children:"balanceToBigNumber"}),", ",(0,t.jsx)(n.code,{children:"instructionMemoToString"}),") for safe conversion. We also handle ",(0,t.jsx)(n.code,{children:"Option"})," types using ",(0,t.jsx)(n.code,{children:".unwrapOrDefault()"})," or ",(0,t.jsx)(n.code,{children:".isSome"}),"/",(0,t.jsx)(n.code,{children:".unwrap()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logging:"})," Finally, we log the extracted transfer details along with the block number and extrinsic information for context."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"7-error-handling-and-cleanup",children:"7. Error Handling and Cleanup"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"main"})," function includes a ",(0,t.jsx)(n.code,{children:"catch"})," block to handle potential errors during connection or subscription and, importantly, to clean up the subscription:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"  // Inside the main function:\n  } catch (error) {\n    console.error('Error:', error);\n    // Ensure we unsubscribe if an error occurs after subscription starts\n    if (unsubscribeFinalizedHeads) {\n      unsubscribeFinalizedHeads();\n    }\n    process.exit(1); // Exit if connection/setup fails\n  }\n\n  // Note: In a real application, you'd also want to handle graceful shutdown\n  // (e.g., on SIGINT/SIGTERM) and call unsubscribeFinalizedHeads() there too.\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If any error occurs, it's logged."}),"\n",(0,t.jsxs)(n.li,{children:["Crucially, ",(0,t.jsx)(n.code,{children:"unsubscribeFinalizedHeads()"})," is called if the subscription was successfully established before the error occurred. This closes the WebSocket connection for the subscription and prevents resource leaks."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"full-example-script",children:"Full Example Script"}),"\n",(0,t.jsx)(n.p,{children:"Here is the complete script combining all the parts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",metastring:'title="subscribeEvents.ts"',children:"import { Polymesh } from '@polymeshassociation/polymesh-sdk';\nimport { UnsubCallback } from '@polymeshassociation/polymesh-sdk/types';\nimport {\n  balanceToBigNumber,\n  instructionMemoToString,\n} from '@polymeshassociation/polymesh-sdk/utils/conversion';\n\n// --- Configuration ---\n// Use the WebSocket endpoint of your target Polymesh node\n// (e.g., public testnet, mainnet, or local node from polymesh-dev-env)\nconst nodeUrl = 'wss://testnet-rpc.polymesh.live'; // Example: Public Testnet\n// const nodeUrl = 'ws://localhost:9944'; // Example: Local Node\n\n// --- Global Variables ---\nlet sdk: Polymesh | null = null;\n// Accessing the internal _polkadotApi property from the SDK instance\nlet api: Polymesh['_polkadotApi'] | null = null;\n\n/**\n * Processes block events and handles specific event types like Balances.Transfer.\n * @param hash The block hash for the finalized block.\n */\nasync function processBlockEvents(hash: string): Promise<void> {\n  if (!api) throw new Error('API not initialized');\n\n  try {\n    // Get the full block data using the block hash\n    const finalizedBlock = await api.rpc.chain.getBlock(hash);\n    if (!finalizedBlock) {\n      console.warn(`Block data not found for hash: ${hash}`);\n      return;\n    }\n\n    const blockNumber = finalizedBlock.block.header.number.unwrap().toString();\n    const { extrinsics } = finalizedBlock.block;\n    console.log(`--- Processing Block #${blockNumber} (${hash.substring(0, 10)}...) ---`);\n\n    // Get an API instance at the specific block's state for accurate event querying\n    const apiAtBlock = await api.at(hash);\n\n    // Query all system events that occurred in this block\n    const events = await apiAtBlock.query.system.events();\n\n    if (events.length === 0) {\n      console.log('  No events in this block.');\n      return;\n    }\n\n    // Iterate through each event record in the block\n    events.forEach((record) => {\n      if (!api) throw new Error('API not initialized'); // Check needed inside loop closure\n      const { event, phase } = record;\n      let extrinsicHash: string | undefined;\n      let extrinsicId: number | undefined;\n      let method: string | undefined;\n      let section: string | undefined;\n\n      // Check if the event was emitted during the application phase of an extrinsic\n      if (phase.isApplyExtrinsic) {\n        extrinsicId = phase.asApplyExtrinsic.toNumber();\n        // Retrieve the corresponding extrinsic from the block's list\n        const extrinsic = extrinsics[extrinsicId];\n        if (extrinsic) {\n          extrinsicHash = extrinsic.hash.toString();\n          method = extrinsic.method.method;\n          section = extrinsic.method.section;\n        }\n      }\n\n      // --- Handle Specific Event: balances.Transfer ---\n      if (api.events.balances.Transfer.is(event)) {\n        const balancesEvent = event.data;\n\n        // Extract data using indices corresponding to the event definition\n        const fromDid = balancesEvent[0].unwrapOrDefault().toString();\n        const fromAddress = balancesEvent[1].toString();\n        const toDid = balancesEvent[2].unwrapOrDefault().toString();\n        const toAddress = balancesEvent[3].toString();\n        // Use SDK utility to convert Balance type to BigNumber\n        const amount = balanceToBigNumber(balancesEvent[4]).toString();\n        // Use SDK utility to convert Option<Memo> to string or undefined\n        const memo = balancesEvent[5].isSome\n          ? instructionMemoToString(balancesEvent[5].unwrap())\n          : undefined;\n\n        console.log('  \u2705 Balances.Transfer Event Found:');\n        console.log(`     From DID: ${fromDid || 'N/A'}`);\n        console.log(`     From Addr: ${fromAddress}`);\n        console.log(`     To DID:   ${toDid || 'N/A'}`);\n        console.log(`     To Addr:  ${toAddress}`);\n        console.log(`     Amount:   ${amount}`);\n        if (memo) {\n          console.log(`     Memo:     \"${memo}\"`);\n        }\n        if (extrinsicId !== undefined) {\n          console.log(`     Context: Extrinsic #${extrinsicId} (${section}.${method}), Hash: ${extrinsicHash?.substring(0, 10)}...`);\n        }\n      }\n      // --- Add more 'else if' blocks here to handle other event types ---\n      // else if (api.events.asset.AssetBalanceUpdated.is(event)) {\n      //   // Process AssetBalanceUpdated event...\n      // }\n      // else if (api.events.nft.NFTPortfolioUpdated.is(event)) {\n      //    // Process NFTPortfolioUpdated event...\n      // }\n    });\n  } catch (error) {\n    console.error(`Error processing block ${hash}:`, error);\n    // Decide if the error is fatal or if processing can continue\n  }\n}\n\n/**\n * Main function to connect to Polymesh and subscribe to finalized block headers.\n */\nconst main = async () => {\n  let unsubscribeFinalizedHeads: UnsubCallback | undefined;\n\n  try {\n    console.log(`Connecting to Polymesh node at ${nodeUrl}...`);\n\n    // Connect using the Polymesh SDK\n    sdk = await Polymesh.connect({\n      nodeUrl,\n      polkadot: { noInitWarn: true }, // Suppress warnings during init if desired\n    });\n\n    // Access the underlying @polkadot/api instance configured by the SDK\n    // eslint-disable-next-line no-underscore-dangle\n    api = sdk._polkadotApi;\n\n    // Verify connection by fetching network properties\n    const networkProps = await sdk.network.getNetworkProperties();\n    console.log(\n      'Successfully connected to:',\n      networkProps.name,\n      '| Spec version:',\n      networkProps.version.toString()\n    );\n\n    // Subscribe to finalized block headers\n    console.log('Subscribing to finalized blocks...');\n    unsubscribeFinalizedHeads = await api.rpc.chain.subscribeFinalizedHeads(\n      async (header) => {\n        const blockHash = header.hash.toString();\n        // Process events for the finalized block\n        await processBlockEvents(blockHash);\n      }\n    );\n\n    console.log('Subscription active. Waiting for new blocks... (Press Ctrl+C to exit)');\n\n    // Keep the script running until interrupted (e.g., Ctrl+C)\n    // In a real service, you might have a more robust way to handle lifecycle.\n    await new Promise(() => { /* Keep running indefinitely */ });\n\n  } catch (error) {\n    console.error('Initialization or subscription error:', error);\n    // Attempt to clean up the subscription if it was established\n    if (unsubscribeFinalizedHeads) {\n      console.log('Unsubscribing...');\n      unsubscribeFinalizedHeads();\n    }\n    // Disconnect SDK if initialized\n    if (sdk) {\n       await sdk.disconnect();\n    }\n    process.exit(1);\n  } finally {\n    // Ensure cleanup happens on exit signals (optional but good practice)\n    process.on('SIGINT', () => {\n      console.log('\\nCaught interrupt signal (Ctrl+C). Cleaning up...');\n      if (unsubscribeFinalizedHeads) {\n        unsubscribeFinalizedHeads();\n      }\n      if (sdk) {\n        sdk.disconnect().then(() => process.exit(0));\n      } else {\n        process.exit(0);\n      }\n    });\n  }\n};\n\n// Run the main function\nmain();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["By accessing the ",(0,t.jsx)(n.code,{children:"@polkadot/api"})," instance via ",(0,t.jsx)(n.code,{children:"sdk._polkadotApi"}),", you can leverage the SDK's connection management and type definitions while performing lower-level tasks like subscribing to chain events. This approach provides a powerful way to build real-time monitoring and integration services for the Polymesh blockchain. Remember to handle subscription cleanup properly to avoid resource leaks. While effective for specific use cases like event subscription, always prefer the higher-level Polymesh SDK methods for standard application development tasks."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);