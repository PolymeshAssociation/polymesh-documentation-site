"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[45411],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var i=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=i.createContext({}),c=function(e){var t=i.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=c(e.components);return i.createElement(u.Provider,{value:t},e.children)},y="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,u=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),y=c(n),d=o,h=y["".concat(u,".").concat(d)]||y[d]||p[d]||r;return n?i.createElement(h,a(a({ref:t},l),{},{components:n})):i.createElement(h,a({ref:t},l))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=d;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[y]="string"==typeof e?e:o,a[1]=s;for(var c=2;c<r;c++)a[c]=n[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9492:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>y,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=n(87462),o=(n(67294),n(3905));const r={title:"Authorisations",description:"",subsite:"polymesh-docs"},a=void 0,s={unversionedId:"primitives/authorisations",id:"primitives/authorisations",title:"Authorisations",description:"",source:"@site/polymesh-docs/primitives/authorisations.mdx",sourceDirName:"primitives",slug:"/primitives/authorisations",permalink:"/polymesh-documentation-site/polymesh-docs/primitives/authorisations",draft:!1,tags:[],version:"current",frontMatter:{title:"Authorisations",description:"",subsite:"polymesh-docs"},sidebar:"defaultSidebar",previous:{title:"Non-Fungible Tokens",permalink:"/polymesh-documentation-site/polymesh-docs/primitives/nfts"},next:{title:"Customer Due Diligence",permalink:"/polymesh-documentation-site/polymesh-docs/primitives/cdd"}},u={},c=[{value:"Overview",id:"overview",level:2},{value:"Authorisation Types",id:"authorisation-types",level:2},{value:"Payment for Authorisation",id:"payment-for-authorisation",level:2}],l={toc:c};function y(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,i.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"In many places in Polymesh two identities, or a key and an identity, need to invite each other to have certain types of permission or access."),(0,o.kt)("p",null,"For example, an identity may want to invite a key to join its identity as a secondary key."),(0,o.kt)("p",null,"Authorisations in Polymesh allow an identity to invite another identity or key to take some privileged action."),(0,o.kt)("p",null,"An identity or key can view any authorisations that they may have pending, and can approve or reject each of these authorisations."),(0,o.kt)("h2",{id:"authorisation-types"},"Authorisation Types"),(0,o.kt)("p",null,"There are various types of authorisations that Polymesh allows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum AuthorizationData<AccountId> {\n    /// CDD provider's attestation to change primary key\n    AttestPrimaryKeyRotation(IdentityId),\n    /// Authorization to change primary key\n    RotatePrimaryKey,\n    /// Authorization to transfer a ticker\n    /// Must be issued by the current owner of the ticker\n    TransferTicker(Ticker),\n    /// Add a signer to multisig\n    /// Must be issued to the identity that created the ms (and therefore owns it permanently)\n    AddMultiSigSigner(AccountId),\n    /// Authorization to transfer a token's ownership\n    /// Must be issued by the current owner of the asset\n    TransferAssetOwnership(Ticker),\n    /// Authorization to join an Identity\n    /// Must be issued by the identity which is being joined\n    JoinIdentity(Permissions),\n    /// Authorization to take custody of a portfolio\n    PortfolioCustody(PortfolioId),\n    /// Authorization to become an agent of the `Ticker` with the `AgentGroup`.\n    BecomeAgent(Ticker, AgentGroup),\n    /// Add Relayer paying key to user key\n    /// Must be issued by the paying key.\n    /// `AddRelayerPayingKey(user_key, paying_key, polyx_limit)`\n    AddRelayerPayingKey(AccountId, AccountId, Balance),\n    /// Authorization to change primary key and leave it as a secondary key\n    /// with the given permissions.\n    RotatePrimaryKeyToSecondary(Permissions),\n}\n")),(0,o.kt)("p",null,"Each of these authorisations are issued by an identity, but take different parameters depending on the type of action taking place."),(0,o.kt)("h2",{id:"payment-for-authorisation"},"Payment for Authorisation"),(0,o.kt)("p",null,"In some cases it may not be possible for the approver (or rejector) of an authorisation to pay for the transaction to do so. When a key is joining a new identity, it may not have any POLYX funds to pay for the transaction, and cannot receive POLYX as it is not yet associated with an identity (with a valid CDD claim)."),(0,o.kt)("p",null,"When a multisig signer is proposing or approving a multisig transaction it may similarly not have POLYX (a multisig signer cannot receive POLYX as it is not directly connected to an identity)."),(0,o.kt)("p",null,"So for the certain types of authorisation below, the transaction is paid for by the issuer of the authorisation, in particular the primary key of the identity that issued the authorisation."),(0,o.kt)("p",null,"Authorisations types where the authorisation issuer pays are:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    AcceptMultiSigSigner,\n    AcceptRelayerPayingKey,\n    AcceptIdentitySecondary,\n    AcceptIdentityPrimary,\n    RotatePrimaryToSecondary,\n    /// Matches any call to `remove_authorization`,\n    /// where the authorization is available for `auth.authorized_by` payer redirection.\n    RemoveAuthorization,\n")))}y.isMDXComponent=!0}}]);