"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[89994],{1593:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/polyx/fees","title":"Network Fees","description":"Transaction and Protocol Fees","source":"@site/docs/200-core-concepts/020-polyx/fees.md","sourceDirName":"200-core-concepts/020-polyx","slug":"/polyx/fees","permalink":"/polymesh-documentation-site/polyx/fees","draft":false,"unlisted":false,"editUrl":"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/docs/200-core-concepts/020-polyx/fees.md","tags":[{"inline":true,"label":"fees","permalink":"/polymesh-documentation-site/tags/fees"},{"inline":true,"label":"transactions","permalink":"/polymesh-documentation-site/tags/transactions"}],"version":"current","frontMatter":{"title":"Network Fees","description":"Transaction and Protocol Fees","id":"fees","slug":"/polyx/fees","sidebar_label":"Network Fees","tags":["fees","transactions"]},"sidebar":"docs","previous":{"title":"POLYX","permalink":"/polymesh-documentation-site/polyx"},"next":{"title":"Staking","permalink":"/polymesh-documentation-site/polyx/staking"}}');var o=n(74848),i=n(28453);const a={title:"Network Fees",description:"Transaction and Protocol Fees",id:"fees",slug:"/polyx/fees",sidebar_label:"Network Fees",tags:["fees","transactions"]},r=void 0,c={},l=[{value:"Overview",id:"overview",level:2},{value:"Transaction Fees",id:"transaction-fees",level:2},{value:"Protocol Fees",id:"protocol-fees",level:2},{value:"Fee Subsidization",id:"fee-subsidization",level:2}];function h(e){const t={a:"a",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(t.p,{children:["Fees on Polymesh are paid in the networks native token, ",(0,o.jsx)(t.a,{href:"/polyx/",children:"POLYX"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"There are two types of network fee:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Transaction Fees - always paid whether or not the transaction is successful"}),"\n",(0,o.jsx)(t.li,{children:"Protocol Fees - only paid for successful transactions"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"transaction-fees",children:"Transaction Fees"}),"\n",(0,o.jsx)(t.p,{children:"Every on-chain transaction in Polymesh must be paid for using POLYX. The cost of the operation is proportional to the computational and storage complexity of the action being performed and is set directly by the network."}),"\n",(0,o.jsx)(t.p,{children:"In order to execute an on-chain transaction, a user must have sufficient POLYX associated with the key which is signing and submitting the transaction. If there isn't a sufficient balance, the network will fail the transaction."}),"\n",(0,o.jsx)(t.p,{children:"Transaction fees go to the operator that produced the block containing the associated transaction. This means that operators are incentivised to help increase adoption of the network (as they receive a percentage of transaction fees from on-chain activity)."}),"\n",(0,o.jsx)(t.p,{children:"All transactions in Polymesh have a transaction fee associated with them. The magnitude of the fee is determined by:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"The computational cost of executing the transaction"}),"\n",(0,o.jsx)(t.li,{children:"The memory/storage cost"}),"\n",(0,o.jsx)(t.li,{children:"The size (in bytes) of the transaction input"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The transaction fee is paid regardless of whether the transaction is successful or not."}),"\n",(0,o.jsxs)(t.p,{children:["To get an indication of current transaction fees, you can use block explorer tools like ",(0,o.jsx)(t.a,{href:"https://polymesh.subscan.io/",children:"Polymesh Subscan"})," to view recent transaction costs"]}),"\n",(0,o.jsx)(t.h2,{id:"protocol-fees",children:"Protocol Fees"}),"\n",(0,o.jsx)(t.p,{children:"In addition to transaction fees, certain on-chain transactions carry additional fixed fees."}),"\n",(0,o.jsx)(t.p,{children:"The transactions that carry these additional protocol fees are configurable and can be updated via the governance process - modifying both the transactions that carry these fees, as well as the fee amounts for each transaction."}),"\n",(0,o.jsx)(t.p,{children:"Currently only one types of transaction carries additional fees - this is:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"registering a new ticker: this has a 25 POLYX fee. Ticker registration is optional and only required if you wish to have a unique ticker linked to your asset."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Both transaction and protocol fees are paid to the operator that produces a block that includes the relevant transactions."}),"\n",(0,o.jsx)(t.p,{children:"Protocol fees are only paid by a user if their action is successful - for example if you try and register a ticker that has already been registered, you won't be charged the 25 POLYX protocol fee."}),"\n",(0,o.jsx)(t.h2,{id:"fee-subsidization",children:"Fee Subsidization"}),"\n",(0,o.jsxs)(t.p,{children:["To reduce friction for users, Polymesh supports transaction fee subsidization where one account (the subsidizer) can pay fees on behalf of another account. This is particularly useful for businesses wanting to cover transaction costs for their users. For more details on this feature, see the ",(0,o.jsx)(t.a,{href:"/accounts/subsidized",children:"Subsidized Accounts"})," documentation."]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(96540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);