"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[39115],{89997:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"primitives/authorisations","title":"Authorisations","description":"","source":"@site/polymesh-docs/primitives/authorisations.mdx","sourceDirName":"primitives","slug":"/primitives/authorisations","permalink":"/polymesh-documentation-site/polymesh-docs/primitives/authorisations","draft":false,"unlisted":false,"editUrl":"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/polymesh-docs/primitives/authorisations.mdx","tags":[],"version":"current","frontMatter":{"title":"Authorisations","description":"","subsite":"polymesh-docs"},"sidebar":"defaultSidebar","previous":{"title":"Settlement Sequence Diagrams","permalink":"/polymesh-documentation-site/polymesh-docs/primitives/settlement/settlement-diagrams"},"next":{"title":"Customer Due Diligence","permalink":"/polymesh-documentation-site/polymesh-docs/primitives/cdd"}}');var o=i(74848),a=i(28453);const s={title:"Authorisations",description:"",subsite:"polymesh-docs"},r=void 0,c={},h=[{value:"Overview",id:"overview",level:2},{value:"Authorisation Types",id:"authorisation-types",level:2},{value:"Payment for Authorisation",id:"payment-for-authorisation",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(t.p,{children:"In many places in Polymesh two identities, or a key and an identity, need to invite each other to have certain types of permission or access."}),"\n",(0,o.jsx)(t.p,{children:"For example, an identity may want to invite a key to join its identity as a secondary key."}),"\n",(0,o.jsx)(t.p,{children:"Authorisations in Polymesh allow an identity to invite another identity or key to take some privileged action."}),"\n",(0,o.jsx)(t.p,{children:"An identity or key can view any authorisations that they may have pending, and can approve or reject each of these authorisations."}),"\n",(0,o.jsx)(t.h2,{id:"authorisation-types",children:"Authorisation Types"}),"\n",(0,o.jsx)(t.p,{children:"There are various types of authorisations that Polymesh allows:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"pub enum AuthorizationData<AccountId> {\n    /// CDD provider's attestation to change primary key\n    AttestPrimaryKeyRotation(IdentityId),\n    /// Authorization to change primary key\n    RotatePrimaryKey,\n    /// Authorization to transfer a ticker\n    /// Must be issued by the current owner of the ticker\n    TransferTicker(Ticker),\n    /// Add a signer to multisig\n    /// Must be issued to the identity that created the ms (and therefore owns it permanently)\n    AddMultiSigSigner(AccountId),\n    /// Authorization to transfer a token's ownership\n    /// Must be issued by the current owner of the asset\n    TransferAssetOwnership(Ticker),\n    /// Authorization to join an Identity\n    /// Must be issued by the identity which is being joined\n    JoinIdentity(Permissions),\n    /// Authorization to take custody of a portfolio\n    PortfolioCustody(PortfolioId),\n    /// Authorization to become an agent of the `Ticker` with the `AgentGroup`.\n    BecomeAgent(Ticker, AgentGroup),\n    /// Add Relayer paying key to user key\n    /// Must be issued by the paying key.\n    /// `AddRelayerPayingKey(user_key, paying_key, polyx_limit)`\n    AddRelayerPayingKey(AccountId, AccountId, Balance),\n    /// Authorization to change primary key and leave it as a secondary key\n    /// with the given permissions.\n    RotatePrimaryKeyToSecondary(Permissions),\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"Each of these authorisations are issued by an identity, but take different parameters depending on the type of action taking place."}),"\n",(0,o.jsx)(t.h2,{id:"payment-for-authorisation",children:"Payment for Authorisation"}),"\n",(0,o.jsx)(t.p,{children:"In some cases it may not be possible for the approver (or rejector) of an authorisation to pay for the transaction to do so. When a key is joining a new identity, it may not have any POLYX funds to pay for the transaction, and cannot receive POLYX as it is not yet associated with an identity (with a valid CDD claim)."}),"\n",(0,o.jsx)(t.p,{children:"When a multisig signer is proposing or approving a multisig transaction it may similarly not have POLYX (a multisig signer cannot receive POLYX as it is not directly connected to an identity)."}),"\n",(0,o.jsx)(t.p,{children:"So for the certain types of authorisation below, the transaction is paid for by the issuer of the authorisation, in particular the primary key of the identity that issued the authorisation."}),"\n",(0,o.jsx)(t.p,{children:"Authorisations types where the authorisation issuer pays are:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"    AcceptMultiSigSigner,\n    AcceptRelayerPayingKey,\n    AcceptIdentitySecondary,\n    AcceptIdentityPrimary,\n    RotatePrimaryToSecondary,\n    /// Matches any call to `remove_authorization`,\n    /// where the authorization is available for `auth.authorized_by` payer redirection.\n    RemoveAuthorization,\n"})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>r});var n=i(96540);const o={},a=n.createContext(o);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);