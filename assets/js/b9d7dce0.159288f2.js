"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[33351],{36416:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=t(74848),i=t(28453);const s={sidebar_position:5,title:"With the SDK",description:"Settlement with the Polymesh SDK",slug:"/settlement/sdk/"},r=void 0,o={id:"settlement/settlement-sdk",title:"With the SDK",description:"Settlement with the Polymesh SDK",source:"@site/docs/05-settlement/settlement-sdk.mdx",sourceDirName:"05-settlement",slug:"/settlement/sdk/",permalink:"/polymesh-documentation-site/docs/settlement/sdk/",draft:!1,unlisted:!1,editUrl:"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/docs/05-settlement/settlement-sdk.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"With the SDK",description:"Settlement with the Polymesh SDK",slug:"/settlement/sdk/"},sidebar:"defaultSidebar",previous:{title:"External Agents",permalink:"/polymesh-documentation-site/docs/settlement/settlement-agents/"},next:{title:"Executing Actions",permalink:"/polymesh-documentation-site/docs/actions/"}},d={},l=[{value:"Participants",id:"participants",level:2},{value:"Alice&#39;s trading portfolio",id:"alices-trading-portfolio",level:2},{value:"US dollar?",id:"us-dollar",level:2},{value:"Future compliance issue?",id:"future-compliance-issue",level:2},{value:"Further processes",id:"further-processes",level:2},{value:"NextDaq create the instruction",id:"nextdaq-create-the-instruction",level:2},{value:"The custodians approve",id:"the-custodians-approve",level:2},{value:"The instruction is executed",id:"the-instruction-is-executed",level:2},{value:"The exchange verifies",id:"the-exchange-verifies",level:2},{value:"Custodian&#39;s risk",id:"custodians-risk",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{TabItem:t,Tabs:s}=n;return t||h("TabItem",!0),s||h("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["When distributing the ACME token, we used a ",(0,a.jsx)(n.strong,{children:"settlement instruction"}),". This is the proper Polymesh construct to allow a transfer of a security token. The instruction we used had a single leg, i.e. it had a single action. Here we are going to use the same construct, with more legs."]}),"\n",(0,a.jsx)(n.h2,{id:"participants",children:"Participants"}),"\n",(0,a.jsx)(n.p,{children:"Here, Alice, the individual, wants to start trading and exchange some of her ACME shares for US dollars. For that, she enlists the services of a broker named SafeHands who has access to an exchange named NextDaq. She plans on instructing SafeHands to list 1,000 of her shares for at least 5 USD apiece, and let them handle the reception of USD and the transfer execution in a timely manner."}),"\n",(0,a.jsxs)(n.p,{children:["Like we saw before, each participant has an identity and a computer on which they can instantiate their Polymesh client. And inform each other off-chain of their respective ",(0,a.jsx)(n.code,{children:"did"})," so they know how to identify, target, and respond to each other."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Alice:"}),"\n"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const signingManagerAlice: LocalSigningManager =\n  await LocalSigningManager.create({\n    accounts: [\n      {\n        mnemonic: 'word1 word2 ...',\n      },\n    ],\n  });\n\nconst apiAlice: Polymesh = await Polymesh.connect({\n  nodeUrl: 'wss://testnet-rpc.polymesh.live', // or your preferred node\n  signingManager: signingManagerAlice,\n});\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const signingManagerAlice = await LocalSigningManager.create({\n  accounts: [\n    {\n      mnemonic: 'word1 word2 ...',\n    },\n  ],\n});\n\nconst apiAlice = await Polymesh.connect({\n  nodeUrl: 'wss://testnet-rpc.polymesh.live', // or your preferred node\n  signingManager: signingManagerAlice,\n});\n"})})})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"SafeHands:"}),"\n"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const signingManagerSafeHands: LocalSigningManager =\n  await LocalSigningManager.create({\n    accounts: [\n      {\n        mnemonic: 'word41 word42 ...',\n      },\n    ],\n  });\nconst apiSafeHands: Polymesh = await Polymesh.connect({\n  nodeUrl: 'wss://testnet-rpc.polymesh.live', // or your preferred node\n  signingManager: signingManagerSafeHands,\n});\nconst safeHands: Identity = await apiSafeHands.getSigningIdentity();\nconst safeHandsDid: string = safeHands.did; // For Alice and NextDaq\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const signingManagerSafeHands = await LocalSigningManager.create({\n  accounts: [\n    {\n      mnemonic: 'word41 word42 ...',\n    },\n  ],\n});\nconst apiSafeHands = await Polymesh.connect({\n  nodeUrl: 'wss://testnet-rpc.polymesh.live', // or your preferred node\n  signingManager: signingManagerSafeHands,\n});\nconst safeHands = await apiSafeHands.getSigningIdentity();\nconst safeHandsDid = safeHands.did; // For Alice and NextDaq\n"})})})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"NextDaq:"}),"\n"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const signingManagerNextDaq: LocalSigningManager =\n  await LocalSigningManager.create({\n    accounts: [\n      {\n        mnemonic: 'word51 word52 ...',\n      },\n    ],\n  });\nconst apiNextDaq: Polymesh = await Polymesh.connect({\n  nodeUrl: 'wss://testnet-rpc.polymesh.live', // or your preferred node\n  signingManager: signingManagerNextDaq,\n});\nconst nextDaq: Identity = await apiNextDaq.getSigningIdentity();\nconst nextDaqDid: string = nextDaq.did; // For SafeHands\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const apiNextDaq = await Polymesh.connect({\n  nodeUrl: 'wss://testnet-rpc.polymesh.live', // or your preferred node\n  accountMnemonic: 'word51 word52 ...',\n});\nconst nextDaq: Identity = await apiNextDaq.getSigningIdentity();\nconst nextDaqDid: string = nextDaq.did; // For SafeHands\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"alices-trading-portfolio",children:"Alice's trading portfolio"}),"\n",(0,a.jsxs)(n.p,{children:["We saw earlier that Alice kept her ACME shares in her portfolio named ",(0,a.jsx)(n.em,{children:"Cold store"}),", with id ",(0,a.jsx)(n.code,{children:"coldStoreId"}),". It was not meant for trading. But since she wants to trade part of it, she is going to separate her concerns by:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Creating a new ",(0,a.jsx)(n.em,{children:"Trading"})," portfolio."]}),"\n"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const tradingFolioQueue: TransactionQueue<NumberedPortfolio> =\n  await apiAlice.identities.createPortfolio({\n    name: 'Trading',\n  });\nconst tradingFolio: NumberedPortfolio = await tradingFolioQueue.run();\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const tradingFolioQueue = await apiAlice.identities.createPortfolio({\n  name: 'Trading',\n});\nconst tradingFolio = await tradingFolioQueue.run();\n"})})})]}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"Now, let her move 1,000 of her ACME tokens."}),"\n"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const coldStore: NumberedPortfolio = await alice.portfolios.getPortfolio({\n  portfolioId: new BigNumber(coldStoreId),\n});\nconst moveQueue: TransactionQueue<void> = await coldStore.moveFunds({\n  items: [\n    {\n      asset: 'ACME',\n      amount: new BigNumber('1000'),\n    },\n  ],\n  to: tradingFolio,\n});\nawait moveQueue.run();\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const coldStore = await alice.portfolios.getPortfolio({\n  portfolioId: new BigNumber(coldStoreId),\n});\nconst moveQueue = await coldStore.moveFunds({\n  items: [\n    {\n      asset: 'ACME',\n      amount: new BigNumber('1000'),\n    },\n  ],\n  to: tradingFolio,\n});\nawait moveQueue.run();\n"})})})]}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsx)(n.li,{children:"She did this, not for cosmetic reasons, but because she also intends to give SafeHands custodial rights on this Trading portfolio. And only this one."}),"\n"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const custodyQueue: TransactionQueue<void> = await tradingFolio.setCustodian({\n  targetIdentity: safeHandsDid,\n});\nawait custodyQueue.run();\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const custodyQueue = await tradingFolio.setCustodian({\n  targetIdentity: safeHandsDid,\n});\nawait custodyQueue.run();\n"})})})]}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsx)(n.li,{children:"She cannot just dump it on SafeHands, though. They have to accept the custodial relationship in return. So let's move to SafeHands computer system and accept it."}),"\n"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const pendingAuthorizations: AuthorizationRequest[] =\n  await safeHands.authorizations.getReceived();\nconst custodialAuthorization: AuthorizationRequest = pendingAuthorizations.find(\n  (pendingAuthorization: AuthorizationRequest) => {\n    return pendingAuthorization.issuer.did === aliceDid;\n  }\n);\nconst acceptQueue: TransactionQueue<void> =\n  await custodialAuthorization.accept();\nawait acceptQueue.run();\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const pendingAuthorizations = await safeHands.authorizations.getReceived();\nconst custodialAuthorization = pendingAuthorizations.find(\n  (pendingAuthorization) => {\n    return pendingAuthorization.issuer.did === aliceDid;\n  }\n);\nconst acceptQueue = await custodialAuthorization.accept();\nawait acceptQueue.run();\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"At this point, Alice can simply interact with SafeHands on their platform, and direct them to what she wants to achieve. Her broker could also choose to display in her account that she has entrusted them with 1,000 ACME shares, to keep her informed of the status of her account."}),"\n",(0,a.jsx)(n.h2,{id:"us-dollar",children:"US dollar?"}),"\n",(0,a.jsx)(n.p,{children:"We are going to use an on-chain representation of the US dollar. It can be as conceptually simple as another security token issued by a bank. Let's name our bank DeepPockets, and have them issue the token named DEEPUSD."}),"\n",(0,a.jsx)(n.p,{children:"DeepPockets happens to have a sterling reputation, so Polymesh network participants believe them when they claim that they will honour anyone wishing to redeem its DEEPUSD token against off-chain USD 1 for 1. This setup is convenient as, later on, it will allow the trade to have all its components on chain."}),"\n",(0,a.jsxs)(n.p,{children:["Additionally, Alice is not interested in this DEEPUSD. This is a ",(0,a.jsx)(n.em,{children:"detail"})," that her broker is going to hide away from her. Instead, SafeHands will own the DEEPUSD on-chain while Alice's account will display that she owns USD. And if she decides to withdraw them, then she would quite naturally provide banking details to SafeHands ",(0,a.jsx)(n.em,{children:"as per usual"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"SafeHands will collect all DEEPUSD in its own identity's default portfolio."}),"\n",(0,a.jsx)(n.h2,{id:"future-compliance-issue",children:"Future compliance issue?"}),"\n",(0,a.jsx)(n.p,{children:"We already know that when Alice eventually sells some ACME shares, the instruction will need for compliance to be satisfied on her side before it gets executed. One cannot predict the future. But SafeHands, mindful of maintaining its reputation with NextDaq, still wants to confirm that, were it to happen today, Alice could send her shares."}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const acmeAsset: Asset = await apiSafeHands.assets.getAsset({\n  ticker: 'ACME',\n});\nconst transfer: TransferBreakdown = await acmeAsset.settlements.canTransfer({\n  amount: new BigNumber('1'),\n  from: {\n    did: aliceDid,\n    id: tradingFolio.id,\n  },\n  to: aliceDid,\n});\nassert(transfer.result === true);\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const acmeAsset = await apiSafeHands.assets.getAsset({\n  ticker: 'ACME',\n});\nconst transfer = await acmeAsset.settlements.canTransfer({\n  amount: new BigNumber('1'),\n  from: {\n    did: aliceDid,\n    id: tradingFolio.id,\n  },\n  to: aliceDid,\n});\nassert(transfer.result === true);\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"This test will unfortunately also test whether Alice can receive new ACME shares, which is one irrelevant hurdle SafeHands doesn't care about."}),"\n",(0,a.jsxs)(n.p,{children:["If SafeHands, or any other custodian, have a customer who wants to acquire some ACME shares, they would have to make sure that they satisfy the ",(0,a.jsx)(n.em,{children:"receive"})," part of the compliance. If you recall, it was defined as:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Have a KYC claim. As per the exercise from ACME itself, which is an artefact of keeping the exercise simpler, although it could be from any KYC service provider as per ACME's choice. Let's name it EzKyc. Presumably a provider that is tasked with verifying the customer's jurisdiction so as to meaningfully satisfy the second point;"}),"\n",(0,a.jsx)(n.li,{children:"Not have a claimed jurisdiction of Liechtenstein."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["What would it look like if EzKyc were to publish a claim against Bob, with DID of ",(0,a.jsx)(n.code,{children:"bobDid"}),", valid for 1 year, for the purpose of receiving ACME tokens?"]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const nextYear: Date = new Date();\nnextYear.setFullYear(nextYear.getFullYear() + 1);\nconst claimQueue: TransactionQueue<void> = await apiEzKyc.claims.addClaims({\n  claims: [\n    {\n      claim: {\n        type: ClaimType.Jurisdiction,\n        code: CountryCode.Gb,\n        scope: {\n          type: ScopeType.Ticker,\n          value: 'ACME',\n        },\n      },\n      expiry: nextYear,\n      target: bobDid,\n    },\n  ],\n});\nawait claimQueue.run();\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const nextYear = new Date();\nnextYear.setFullYear(nextYear.getFullYear() + 1);\nconst claimQueue = await apiEzKyc.claims.addClaims({\n  claims: [\n    {\n      claim: {\n        type: 'Jurisdiction',\n        code: 'Gb',\n        scope: {\n          type: 'Ticker',\n          value: 'ACME',\n        },\n      },\n      expiry: nextYear,\n      target: bobDid,\n    },\n  ],\n});\nawait claimQueue.run();\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"This action is done by EzKyc, not by SafeHands or any other custodian. Although it is conceivable that said custodians would direct their customers to the actions they need to complete before they can move forward."}),"\n",(0,a.jsx)(n.h2,{id:"further-processes",children:"Further processes"}),"\n",(0,a.jsx)(n.p,{children:"Ok, now Alice has set up her portfolio for trading, gave a green light to SafeHands and received one from them. Time to wave our hands about the next off-chain steps that take place:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Alice informs SafeHands that they should list her shares for 5 USD a piece;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["SafeHands turn to NextDaq and list them for sale on her behalf. NextDaq return an order id to SafeHands, ",(0,a.jsx)(n.code,{children:"aliceOrderId"}),", for both parties to keep as a reference;"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"There happens to be an interested buying party, Bob, for 200 shares at 5 USD a piece;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Bob is represented by his custodian OnTrust, who received the order id ",(0,a.jsx)(n.code,{children:"bobOrderId"})," when they listed his order;"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Bob has also prepared a trading portfolio;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"NextDaq match SafeHands and OnTrust for a trade of 200 shares at 5 USD a piece;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"NextDaq remove Bob's order and dock 200 ACME from Alice's standing order;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["NextDaq send ",(0,a.jsx)(n.code,{children:"aliceOrderId"})," to SafeHands off-chain, and ask them for the necessary information to include in the instruction. SafeHands answer off-chain with usable information, for instance a JSON like:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n    "ACME": {\n        "from": {\n            "identity": aliceDid,\n            "id": tradingFolio.id.toString(10)\n        }\n    },\n    "DEEPUSD": {\n        "to": safeHandsDid\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["When SafeHands simply send their ",(0,a.jsx)(n.code,{children:"safeHandsDid"}),", it means that the DEEPUSD tokens will be received in SafeHands' default portfolio;"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["NextDaq send ",(0,a.jsx)(n.code,{children:"bobOrderId"})," to OnTrust off-chain, and ask them for the necessary information to include in the instruction. OnTrust answer off-chain with usable information, for instance:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n    "ACME": {\n        "to": {\n            "identity": bobDid,\n            "id": bobTargetPortfolio.id.toString(10)\n        }\n    },\n    "DEEPUSD": {\n        "from": onTrustDid\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With this information, and after some cross-checking, NextDaq is able to understand that the instruction legs are going to be as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'const legs = [\n    {\n        "asset": "ACME",\n        "amount": new BigNumber("200"),\n        "from": {\n            // This is the view from SafeHands. What NextDaq see is a string like "0x55678..."\n            "identity": aliceDid,\n            // This is the view from SafeHands. What NextDaq see is a string like "1"\n            "id": tradingFolio.id.toString(10)\n        },\n        "to": {\n            // This is the view from OnTrust. What NextDaq see is a string like "0x39987..."\n            "identity": bobDid,\n            // This is the view from OnTrust. What NextDaq see is a string like "2"\n            "id": bobTargetPortfolio.id.toString(10)\n        }\n    },\n    {\n        "asset": "DEEPUSD",\n        "amount": new BigNumber("1000"),\n        // This is the view from OnTrust. What NextDaq see is a string like "0x11907..."\n        "from": onTrustDid,\n        // This is the view from SafeHands. What NextDaq see is a string like "0x26061..."\n        "to": safeHandsDid\n    }\n];\n'})}),"\n",(0,a.jsx)(n.h2,{id:"nextdaq-create-the-instruction",children:"NextDaq create the instruction"}),"\n",(0,a.jsx)(n.p,{children:"For the purpose of this exercise we assume that Alice and Bob are not customers of the same broker. If they actually were, it would be simpler as NextDaq could notify SafeHands that they should handle it on their own. SafeHands would just create a portfolio-to-portfolio move transaction and voila. It could even be the case that SafeHands would have identified the match on their own, modified the first standing order, and handled both of them internally even before NextDaq saw the matching order."}),"\n",(0,a.jsxs)(n.p,{children:["Back to Alice and Bob working with ",(0,a.jsx)(n.strong,{children:"different brokers"}),". Let's reasonably assume that NextDaq has already created a venue where it sends all trade instructions: ",(0,a.jsx)(n.code,{children:"tradeVenue"}),"."]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const tradeInstructionQueue: TransactionQueue<Instruction> =\n  await tradeVenue.addInstruction({\n    legs: legs,\n  });\nconst tradeInstruction: Instruction = await tradeInstructionQueue.run();\nconst tradeInstructionId: string = tradeInstruction.id.toString(10);\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const tradeInstructionQueue = await tradeVenue.addInstruction({\n  legs: legs,\n});\nconst tradeInstruction = await tradeInstructionQueue.run();\nconst tradeInstructionId = tradeInstruction.id.toString(10);\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"Now NextDaq can turn back to SafeHands with what they need to accept:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n    "orderId": aliceOrderId,\n    "tradeId": tradeInstructionId\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"And similarly to OnTrust with:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n    "orderId": bobOrderId,\n    "tradeId": tradeInstructionId\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The instruction is out, the brokers have been informed. The onus is now on the brokers/custodians to affirm it. Additionally, NextDaq, with a view to monitoring the reliability of their brokers on the trading platform, stores ",(0,a.jsx)(n.code,{children:"tradeInstructionId"})," so that it can later confirm that it has been executed."]}),"\n",(0,a.jsx)(n.h2,{id:"the-custodians-approve",children:"The custodians approve"}),"\n",(0,a.jsxs)(n.p,{children:["Let's look at what it would look like from SafeHands point of view. Because Alice is not their only client, they would likely see a lot of activity, so, although they have a certain level of trust about ",(0,a.jsx)(n.code,{children:"tradeVenue"}),", they need to make sure that there is no spam or fraud going on. They have already instantiated ",(0,a.jsx)(n.code,{children:"tradeVenue"})," with ",(0,a.jsx)(n.code,{children:"apiSafeHands"}),", as a matter of course."]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const instructions: Instruction[] = await tradeVenue.getInstructions();\nconst aliceInstruction: Instruction = instructions.pending.find(\n  (instruction: Instruction) => {\n    return instruction.id.isEqualTo(new BigNumber(tradeInstructionId));\n  }\n);\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const instructions = await tradeVenue.getInstructions();\nconst aliceInstruction = instructions.pending.find(\n  (instruction: Instruction) => {\n    return instruction.id.isEqualTo(new BigNumber(tradeInstructionId));\n  }\n);\n"})})})]}),"\n",(0,a.jsxs)(n.p,{children:["Let's wave our hands at how SafeHands has an internal system, ",(0,a.jsx)(n.code,{children:"getPlacedOrder()"})," that keeps track of the orders they opened with NextDaq. They have this so they can cross-check when faced with a pending instruction."]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const aliceOrder: SafeOrder = getPlacedOrder(aliceOrderId);\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const aliceOrder = getPlacedOrder(aliceOrderId);\n"})})})]}),"\n",(0,a.jsxs)(n.p,{children:["It returns previously-known information about ",(0,a.jsx)(n.code,{children:"aliceOrderId"})," in the shape of:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n    "asset": "ACME",\n    "amount": new BigNumber("1000"),\n    "from": {\n        "identity": aliceDid,\n        "id": tradingFolio.id\n    },\n    "to": {\n        "identity": safeHandsDid,\n        "id": null\n    },\n    "price": {\n        "asset": "DEEPUSD",\n        "amount": new BigNumber("5")\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Now, SafeHands needs to live up to their name and only affirm the instruction if it is one they recognise. Polymesh, at the API level, allows one to affirm a single leg for a single portfolio. However the SDK finds the relevant legs and portfolios for you, and in turn adds all the necessary affirmations in the transaction queue. The flip side of this convenience is that SafeHands therefore have to make sure nothing untoward was slipped in."}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const legs: ResultSet<Leg> = await aliceInstruction.getLegs();\n\n// Is the instruction's shape as expected?\nassert(legs.count === 2);\n\nconst aliceLegs: Leg[] = legs.data.filter((leg: Leg) => {\n  return (\n    leg.from.did === aliceOrder.from.identity &&\n    leg.from.id.isEqualTo(aliceOrder.from.id) &&\n    leg.asset.ticker === aliceOrder.asset &&\n    leg.amount.isLessThanOrEqualTo(aliceOrder.amount)\n  );\n});\n// Is it even about Alice's shares?\nassert(aliceLegs.length === 1);\nconst soldAmount: BigNumber = aliceLegs[0].amount;\nconst expectedUsd: BigNumber = soldAmount.multipliedBy(aliceOrder.price.amount);\n\nconst paymentLegs: Leg[] = legs.data.filter((leg: Leg) => {\n  return (\n    leg.to.did === aliceOrder.to.identity &&\n    leg.to.id.isEqualTo(aliceOrder.to.id) &&\n    leg.asset.ticker === aliceOrder.price.asset &&\n    leg.amount.isMoreThanEqualTo(expectedUsd)\n  );\n});\n// Are we getting paid in our default portfolio?\nassert(payment.length === 1);\n\nconst paymentLeg: Leg = paymentLegs[0];\nconst payerFolio: Portfolio = new Portfolio({\n  did: paymentLeg.from.did,\n  id: paymentLeg.from.id,\n});\nconst payerCustodian: Identity = await payerFolio.getCustodian();\n// Is someone trying to pay us with our own money?\n// Or with money from one of our clients?\nif (\n  paymentLeg.from.did === safeHandsDid ||\n  payerCustodian.did === safeHandsDid\n) {\n  const rejectQueue: TransactionQueue<Instruction> =\n    await aliceInstruction.reject();\n  await rejectQueue.run();\n  // TODO keep a trace of this attempted fraud in a reputation system.\n} else {\n  const acceptQueue: TransactionQueue<Instruction> =\n    await aliceInstruction.affirm();\n  await acceptQueue.run();\n}\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const legs = await aliceInstruction.getLegs();\n\n// Is the instruction's shape as expected?\nassert(legs.count === 2);\n\nconst aliceLegs = legs.data.filter((leg) => {\n  return (\n    leg.from.did === aliceOrder.from.identity &&\n    leg.from.id.isEqualTo(aliceOrder.from.id) &&\n    leg.asset.ticker === aliceOrder.asset &&\n    leg.amount.isLessThanOrEqualTo(aliceOrder.amount)\n  );\n});\n// Is it even about Alice's shares?\nassert(aliceLegs.length === 1);\nconst soldAmount = aliceLegs[0].amount;\nconst expectedUsd = soldAmount.multipliedBy(aliceOrder.price.amount);\n\nconst paymentLegs = legs.data.filter((leg) => {\n  return (\n    leg.to.did === aliceOrder.to.identity &&\n    leg.to.id.isEqualTo(aliceOrder.to.id) &&\n    leg.asset.ticker === aliceOrder.price.asset &&\n    leg.amount.isMoreThanEqualTo(expectedUsd)\n  );\n});\n// Are we getting paid in our default portfolio?\nassert(payment.length === 1);\n\nconst paymentLeg = paymentLegs[0];\nconst payerFolio = new Portfolio({\n  did: paymentLeg.from.did,\n  id: paymentLeg.from.id,\n});\nconst payerCustodian = await payerFolio.getCustodian();\n// Is someone trying to pay us with our own money?\n// Or with money from one of our clients?\nif (\n  paymentLeg.from.did === safeHandsDid ||\n  payerCustodian.did === safeHandsDid\n) {\n  const rejectQueue = await aliceInstruction.reject();\n  await rejectQueue.run();\n  // TODO keep a trace of this attempted fraud in a reputation system.\n} else {\n  const acceptQueue = await aliceInstruction.affirm();\n  await acceptQueue.run();\n}\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"As you have noticed, the code above acts suspicious about the instruction it is asked to affirm. In particular, it doesn't allow the ACME buyer to be in a custodial relationship with SafeHands. This is justified in our example by the presumption that an internal trade match would be handled internally. On the other hand, if you want to handle such cases coming from the exchange, then you would need to relax this specific requirement."}),"\n",(0,a.jsx)(n.p,{children:"In parallel to SafeHands, OnTrust has to do the same. And provided KYC considerations are satisfied, the trade goes through. So we are done with the trade. But are we done with the exercise?"}),"\n",(0,a.jsx)(n.h2,{id:"the-instruction-is-executed",children:"The instruction is executed"}),"\n",(0,a.jsx)(n.p,{children:"The instruction has been affirmed, but it is possible that it has not been executed yet because of missing compliance from one or more of the parties. Let's assume that the transaction was left pending and is now ready to be executed again, and that it is SafeHands who have decided to post this transaction."}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"assert(await aliceInstruction.isPending());\nconst updatedInstructionQueue: TransactionQueue<Instruction> =\n  await aliceInstruction.reschedule();\nawait updatedInstructionQueue.run();\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"assert(await aliceInstruction.isPending());\nconst updatedInstructionQueue = await aliceInstruction.reschedule();\nawait updatedInstructionQueue.run();\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"With that, the system will reevaluate whether it can execute the instruction, and:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"if yes, will execute it,"}),"\n",(0,a.jsx)(n.li,{children:"if not, will send it back to a pending state."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"the-exchange-verifies",children:"The exchange verifies"}),"\n",(0,a.jsxs)(n.p,{children:["NextDaq trust the brokers to do the deed, but they also verify ",(0,a.jsx)(n.strong,{children:"at the end of the day"})," that the brokers actually did it. NextDaq run a business partly based on the reputation that trades matched on their platform get eventually settled. Let see what they can do about it."]}),"\n",(0,a.jsx)(n.p,{children:"They will collect affirmations on instructions they created. When they collect the affirmations, they always get all of them. Indeed, affirmations start their lifecycle as pending, and their status changes depending on the relevant identity's actions."}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'\n\nconst instructions: Instruction[] = await tradeVenue.getInstructions();\nconst earlierInstruction: Instruction = instructions.pending.find((instruction: Instruction) => {\n    return instruction.id.isEqualTo(new BigNumber(tradeInstructionId));\n});\nif (typeof earlierInstruction === "undefined") {\n    return; // All good\n}\n\nconst affirmations: ResultSet\u2039InstructionAffirmation\u203a = await earlierInstruction.getAffirmations();\n// Discarding ResultSet\'s pagination to simplify.\nconst safeHandsAffirmations: InstructionAffirmation[] = affirmations.data.filter((affirmation: InstructionAffirmation) => {\n    return affirmation.identity.did === safeHandsDid;\n});\nconst onTrustAffirmations: InstructionAffirmation[] = affirmations.data.filter((affirmation: InstructionAffirmation) => {\n    return affirmation.identity.did === onTrustDid;\n});\nsafeHandsAffirmed: boolean = safeHandsAffirmations.every((safeHandsAffirmation: InstructionAffirmation) => {\n    if (safeHandsAffirmation.status === AffirmationStatus.Affirmed) {\n        return true;\n    } else if (safeHandsAffirmation.status === AffirmationStatus.Pending) {\n        // Count 1 strike for SafeHands.\n    } else if (safeHandsAffirmation.status === AffirmationStatus.Rejected) {\n        // Mmh, what could this mean?\n    } else if (safeHandsAffirmation.status === AffirmationStatus.Unknown) {\n        // Status is unknown. What to do?\n    }\n    return false;\n});\n\nonTrustAffirmed: boolean = onTrustAffirmations.every((onTrustAffirmation: InstructionAffirmation) => {\n    if (onTrustAffirmation.status === AffirmationStatus.Affirmed) {\n        return true;\n    } else if (onTrustAffirmation.status === AffirmationStatus.Pending) {\n        // Count 1 strike for OnTrust.\n    } else if (onTrustAffirmation.status === AffirmationStatus.Rejected) {\n        // Mmh, what could this mean?\n    } else if (onTrustAffirmation.status === AffirmationStatus.Unknown) {\n        // Status is unknown. What to do?\n    }\n    return false;\n});\n\nif (safeHandsAffirmed && onTrustAffirmed) {\n    // Do we have a situation with compliance? And how should NextDaq record this failure?\n    // Should NextDaq trigger an execution, and charge back the custodians?\n    await (await earlierInstruction.reschedule()).run();\n}\n'})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const instructions = await tradeVenue.getInstructions();\nconst earlierInstruction = instructions.pending.find(\n  (instruction: Instruction) => {\n    return instruction.id.isEqualTo(new BigNumber(tradeInstructionId));\n  }\n);\nif (typeof earlierInstruction === 'undefined') {\n  return; // All good\n}\n\nconst affirmations = await earlierInstruction.getAffirmations();\n// Discarding ResultSet's pagination to simplify.\nconst safeHandsAffirmations = affirmations.data.filter((affirmation) => {\n  return affirmation.identity.did === safeHandsDid;\n});\nconst onTrustAffirmations = affirmations.data.filter((affirmation) => {\n  return affirmation.identity.did === onTrustDid;\n});\nsafeHandsAffirmed = safeHandsAffirmations.every((safeHandsAffirmation) => {\n  if (safeHandsAffirmation.status === 'Affirmed') {\n    return true;\n  } else if (safeHandsAffirmation.status === 'Pending') {\n    // Count 1 strike for SafeHands.\n  } else if (safeHandsAffirmation.status === 'Rejected') {\n    // Mmh, what could this mean?\n  } else if (safeHandsAffirmation.status === 'Unknown') {\n    // Status is unknown. What to do?\n  }\n  return false;\n});\n\nonTrustAffirmed = onTrustAffirmations.every((onTrustAffirmation) => {\n  if (onTrustAffirmation.status === 'Affirmed') {\n    return true;\n  } else if (onTrustAffirmation.status === 'Pending') {\n    // Count 1 strike for OnTrust.\n  } else if (onTrustAffirmation.status === 'Rejected') {\n    // Mmh, what could this mean?\n  } else if (onTrustAffirmation.status === 'Unknown') {\n    // Status is unknown. What to do?\n  }\n  return false;\n});\n\nif (safeHandsAffirmed && onTrustAffirmed) {\n  // Do we have a situation with compliance? And how should NextDaq record this failure?\n  // Should NextDaq trigger an execution, and charge back the custodians?\n  await (await earlierInstruction.reschedule()).run();\n}\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"custodians-risk",children:"Custodian's risk"}),"\n",(0,a.jsxs)(n.p,{children:["Let's look back at the relationship between Alice and SafeHands. She puts her shares meant for trading in her ",(0,a.jsx)(n.em,{children:"trading"})," portfolio, with SafeHands as the custodian. This means that both Alice and SafeHands can move these shares out of the portfolio to anywhere else. We presume that Alice and SafeHands have entered into a legal contract where they agreed not to pull the rug on each other. In particular, that Alice would not move a single one of her 1,000 shares, while all 1,000 of them are listed on an exchange under the name of SafeHands. Otherwise that would expose SafeHands to a reputation risk, if it were not able to settle an agreed trade."]}),"\n",(0,a.jsx)(n.p,{children:"On top of trusting Alice via a legal agreement, SafeHands can also verify, and monitor the transactions on the blockchain. If they simply look at the current balance after it has been done to adjust accordingly, it is about:"}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const alice: Identity = apiSafeHands.getIdentity(aliceDid);\nconst tradingFolio: NumberedPortfolio = await alice.portfolios.getPortfolio({\n  portfolioId: tradingFolio.id,\n});\nconst acmeAssetBalances: PortfolioBalance[] =\n  await tradingFolio.getAssetBalances({\n    assets: ['ACME'],\n  });\nconst acmeAssetBalance: PortfolioBalance = acmeAssetBalances[0];\n\nif (acmeAssetBalance.total.isLessThan(new BigNumber('1000'))) {\n  // TODO update the order on NextDaq accordingly.\n}\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const alice = apiSafeHands.getIdentity(aliceDid);\nconst tradingFolio = await alice.portfolios.getPortfolio({\n  portfolioId: tradingFolio.id,\n});\nconst acmeAssetBalances = await tradingFolio.getAssetBalances({\n  assets: ['ACME'],\n});\nconst acmeAssetBalance = acmeAssetBalances[0];\n\nif (acmeAssetBalance.total.isLessThan(new BigNumber('1000'))) {\n  // TODO update the order on NextDaq accordingly.\n}\n"})})})]}),"\n",(0,a.jsxs)(n.p,{children:["On the other hand, if they want to pre-emptively change the order on NextDaq as soon as a conflicting pending instruction pops up, they have to go differently. There is an added difficulty around the fact that ",(0,a.jsx)(n.code,{children:".getLegs"})," is an ",(0,a.jsx)(n.code,{children:"async"})," function, but ",(0,a.jsx)(n.code,{children:".filter"})," doesn't take ",(0,a.jsx)(n.code,{children:"async"})," predicates. So we use an array of promises that yields an array of array, which can be flattened."]}),"\n",(0,a.jsxs)(s,{groupId:"code-language",children:[(0,a.jsx)(t,{value:"ts",label:"TypeScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const instructions: Instruction[] = await alice.getInstructions();\nconst fromTradingPromises: Promise<Leg[]>[] = instructions.pending.map(\n  async (instruction: Instruction) => {\n    const legs: ResultSet<Leg> = await instruction.getLegs();\n    const outLegs: Leg[] = legs.data.filter((leg: Leg) => {\n      return (\n        leg.from.owner.did === aliceDid &&\n        typeof leg.from.id !== 'undefined' &&\n        leg.from.id.isEqualTo(tradingFolio.id)\n      );\n    });\n    return outLegs;\n  }\n);\nconst pendingOutLegs: Leg[] = (await Promise.all(fromTradingPromises)).flat();\nconst outAmount: BigNumber = pendingOutLegs.reduce(\n  (amount: BigNumber, leg: Leg) => {\n    return amount.plus(leg.amount);\n  },\n  new BigNumber('0')\n);\nif (outAmount.isGreaterThan(new BigNumber('0'))) {\n  // TODO update the order on NextDaq accordingly.\n}\n"})})}),(0,a.jsx)(t,{value:"js",label:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const instructions = await alice.getInstructions();\nconst fromTradingPromises = instructions.pending.map(async (instruction) => {\n  const legs = await instruction.getLegs();\n  const outLegs = legs.data.filter((leg) => {\n    return (\n      leg.from.owner.did === aliceDid &&\n      typeof leg.from.id !== 'undefined' &&\n      leg.from.id.isEqualTo(tradingFolio.id)\n    );\n  });\n  return outLegs;\n});\nconst pendingOutLegs = (await Promise.all(fromTradingPromises)).flat();\nconst outAmount = pendingOutLegs.reduce((amount, leg) => {\n  return amount.plus(leg.amount);\n}, new BigNumber('0'));\nif (outAmount.isGreaterThan(new BigNumber('0'))) {\n  // TODO update the order on NextDaq accordingly.\n}\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"At this point, depending on the relationship, SafeHands, can decide to update or pull the sell order on the exchange to reflect the future amount. They could also deem the instruction fraudulent and reject it."}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"We have seen how custodians, beneficiaries and an exchange can interact and transact while checking their steps along the way."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);