"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[55139],{32892:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var n=t(74848),i=t(28453);const a={sidebar_position:1,title:"Fungible Assets",description:"",subsite:"polymesh-docs"},r=void 0,o={id:"primitives/assets",title:"Fungible Assets",description:"",source:"@site/polymesh-docs/primitives/assets.mdx",sourceDirName:"primitives",slug:"/primitives/assets",permalink:"/polymesh-documentation-site/polymesh-docs/primitives/assets",draft:!1,unlisted:!1,editUrl:"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/polymesh-docs/primitives/assets.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Fungible Assets",description:"",subsite:"polymesh-docs"},sidebar:"defaultSidebar",previous:{title:"Tokenomics",permalink:"/polymesh-documentation-site/polymesh-docs/network/tokenomics"},next:{title:"Non-Fungible Tokens",permalink:"/polymesh-documentation-site/polymesh-docs/primitives/nfts"}},c={},h=[{value:"Overview",id:"overview",level:2},{value:"Ticker Registration",id:"ticker-registration",level:2},{value:"Asset Creation",id:"asset-creation",level:2},{value:"Documentation",id:"documentation",level:2},{value:"Ownership",id:"ownership",level:2},{value:"Asset Issuers",id:"asset-issuers",level:2},{value:"Issuance",id:"issuance",level:2},{value:"Roles",id:"roles",level:3},{value:"External Agents",id:"external-agents",level:3},{value:"Process",id:"process",level:3},{value:"Checkpoints",id:"checkpoints",level:2},{value:"Creating a checkpoint",id:"creating-a-checkpoint",level:3},{value:"Accessing an existing checkpoint",id:"accessing-an-existing-checkpoint",level:3}];function l(e){const s={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(s.p,{children:"Fungible assets on Polymesh can represent any type of digitalised asset, and are originated and managed through the asset base layer logic in Polymesh."}),"\n",(0,n.jsx)(s.p,{children:"This ensures that all assets are created in a standardised manner, allowing related functionality such as corporate actions, settlement and compliance, to function seamlessly across all assets."}),"\n",(0,n.jsx)(s.p,{children:"Once an asset has been created, its ownership is represented via balances of that assets tokens held by different investors."}),"\n",(0,n.jsx)(s.p,{children:"Ownership of an asset on Polymesh can be determined via its:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"total supply: the total number of tokens that represent ownership in the asset"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"investor balances: the individual balance of each investing identity in the asset"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["The asset pallet documentation can be found at:\n",(0,n.jsx)(s.a,{href:"https://docs.polymesh.live/pallet_asset/index.html",children:"https://docs.polymesh.live/pallet_asset/index.html"})]}),"\n",(0,n.jsx)(s.p,{children:"Polymesh allows you to manage the full lifecycle of any asset directly on the Polymesh blockchain, including the issuance, initial distribution or fund-raise of the asset and any subsequent corporate actions such as dividend payments, capital distributions or corporate ballots."}),"\n",(0,n.jsx)(s.p,{children:"Asset tokens can be either divisible or indivisible."}),"\n",(0,n.jsx)(s.h2,{id:"ticker-registration",children:"Ticker Registration"}),"\n",(0,n.jsx)(s.p,{children:"Every asset on Polymesh has a unique ticker - a 12 character identifier for the asset."}),"\n",(0,n.jsx)(s.p,{children:"Users can register a ticker, and then when they are ready create an asset associated with that registered ticker."}),"\n",(0,n.jsx)(s.p,{children:"Ticker registrations can be transferred between identities and have an expiry date, currently set to 60 days from their initial registration."}),"\n",(0,n.jsx)(s.p,{children:"Registering a ticker ensures no other user can issue an asset with that ticker whilst the registration is valid (i.e. has not expired), and has a protocol fee associated with it (currently 1000 POLYX)."}),"\n",(0,n.jsx)(s.h2,{id:"asset-creation",children:"Asset Creation"}),"\n",(0,n.jsx)(s.p,{children:"Having registered a ticker, users can then create their asset, specifying the type of the asset (e.g. Equity, Bond, Fund)."}),"\n",(0,n.jsxs)(s.p,{children:["The asset is initially created with a zero total supply. For the initial issuance of the asset, see the ",(0,n.jsx)(s.a,{href:"#issuance",children:"Issuance section"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"As well as being identified via a unique ticker, assets can be associated with additional external identifiers, such as ISINs, CUSIPs, CINs, LEIs and DTIs, with Polymesh validating that these identifiers are consistent (i.e. that their checksums match)."}),"\n",(0,n.jsx)(s.p,{children:"If a ticker is not currently reserved, the ticker registration is done automatically when a user creates an asset."}),"\n",(0,n.jsx)(s.h2,{id:"documentation",children:"Documentation"}),"\n",(0,n.jsx)(s.p,{children:"Polymesh allows the issuer of an asset to associate documents with that asset."}),"\n",(0,n.jsx)(s.p,{children:"The actual document is not stored on-chain, and instead the asset is associated with a document reference on-chain, where the reference includes a name, the URL at which the document can be found (this may be a permissioned URL requiring an investor in the asset to have some credentials to access the document), as well as an optional document type, filing date, and hash of the document contents."}),"\n",(0,n.jsx)(s.p,{children:"Documentation can only be updated or modified by the identity that issued the corresponding asset (the asset issuer)."}),"\n",(0,n.jsx)(s.h2,{id:"ownership",children:"Ownership"}),"\n",(0,n.jsxs)(s.p,{children:["All asset ownership in Polymesh is at the identity level. Whilst an investor can organise their assets into different portfolios under their ",(0,n.jsx)(s.a,{href:"../identity/",children:"identity"}),", compliance is enforced at the identity level, so in order to send or receive a particular assets token, the relevant identity must have claims that match the ",(0,n.jsx)(s.a,{href:"../compliance/",children:"compliance"})," rules specified by the asset issuer for the asset."]}),"\n",(0,n.jsx)(s.h2,{id:"asset-issuers",children:"Asset Issuers"}),"\n",(0,n.jsxs)(s.p,{children:["The asset issuer is the identity which registered the ticker and created the asset. The asset issuer can transfer ownership of an asset to another identity by issuing a ",(0,n.jsx)(s.code,{children:"TransferAsset"})," authorisation which must be accepted by the target identity."]}),"\n",(0,n.jsx)(s.p,{children:"The asset issuer also has some additional controls which are solely accessible to them. These include:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"updating documentation and identifiers for their asset"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"freeze and unfreeze any transfers of their asset"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"add and remove compliance rules for their asset"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"permission venues to settle their asset"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"In addition an asset issuer can execute a controller transfer of their token. This allows them to force transfer ownership of their asset tokens from any investor back to the primary issuance agent of the asset. The primary issuance agent is an identity which an asset issuer specifies for their asset, and is responsible for treasury management and token distribution."}),"\n",(0,n.jsx)(s.h2,{id:"issuance",children:"Issuance"}),"\n",(0,n.jsx)(s.p,{children:"The issuance process for assets in Polymesh allows the originator of an asset (the asset issuer) to issue and distribute their asset to investors."}),"\n",(0,n.jsx)(s.h3,{id:"roles",children:"Roles"}),"\n",(0,n.jsx)(s.p,{children:"Every asset, identified by its unique ticker, is associated with one or more identities:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"the asset issuers identity: this is the identity that created the asset"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"external agent identities: these are the (optional) identities responsible for managing the asset on behalf of the issuer"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"external-agents",children:"External Agents"}),"\n",(0,n.jsx)(s.p,{children:"External agents are Polymesh identities that have been granted permissions related to a particular ticker. Their role is to manage the asset - for example compliance rules, documentation and issuance."}),"\n",(0,n.jsx)(s.p,{children:"The issuer of an asset is automatically assigned as an External Agent to their asset, with full Agent permissions."}),"\n",(0,n.jsxs)(s.p,{children:["External Agents can be added to an asset by any existing agent of the asset with appropriate permissions (including the asset issuer initially as they are defaulted to being an External Agent with full permissions) by issuing a ",(0,n.jsx)(s.code,{children:"BecomeAgent"})," authorisation. The External Agent identity then needs to accept this authorisation."]}),"\n",(0,n.jsx)(s.p,{children:"Each External Agent can be placed into a new or existing permission group, with permissions then derived from this group for all agents within it."}),"\n",(0,n.jsx)(s.p,{children:"There are some pre-defined agent permission groups which are:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-rust",children:"pub enum AgentGroup {\n    /// Has all permissions.\n    Full,\n    /// Custom defined agent group drawn from 2).\n    /// The other groups have hard-coded mappings to `Permissions` in code.\n    Custom(AGId),\n    /// Manages identities of agents themselves.\n    ExceptMeta,\n    /// Agent group corresponding to a Corporate Action Agent (CAA) on Polymesh Mainnet v1.\n    PolymeshV1CAA,\n    /// Agent group corresponding to a Primary Issuance Agent (PIA) on Polymesh Mainnet v1.\n    PolymeshV1PIA,\n}\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Alternatively an asset issuer (more generally an External Agent with appropriate permissions) can create a new agent permission group using the ",(0,n.jsx)(s.code,{children:"Custom"})," enum variant, with whatever permissions are appropriate to their use-case, and then add external agents related to their asset to this group."]}),"\n",(0,n.jsxs)(s.p,{children:["Polymesh enforces that there is always at least one identity with ",(0,n.jsx)(s.code,{children:"Full"})," agent permissions to each asset - by default this is the asset issuer, but this can be given to a third-party External Agent by the issuer, and that third-party can then limit the asset issuers agent permission group as needed."]}),"\n",(0,n.jsx)(s.h3,{id:"process",children:"Process"}),"\n",(0,n.jsx)(s.p,{children:"Once an asset issuer has created and configured their asset, they can then issue tokens representing ownership in the asset to themselves or a distribution external agent of the asset."}),"\n",(0,n.jsx)(s.p,{children:"The agent can then distribute those asset tokens to investors directly or via an security token offering, in both cases using the settlement engine."}),"\n",(0,n.jsx)(s.p,{children:"This approach allows a clean separation between the issuance process, which bypasses both the compliance and settlement engine and is restricted to only issuance to the configured agents, and the distribution process which uses both the compliance and settlement engines."}),"\n",(0,n.jsx)(s.h2,{id:"checkpoints",children:"Checkpoints"}),"\n",(0,n.jsxs)(s.p,{children:["An ",(0,n.jsx)(s.em,{children:"asset checkpoint"})," is a collection of records representing the balances of that asset at a given\ntime. The balances recorded are the total asset balance and all the balances held by identities."]}),"\n",(0,n.jsx)(s.p,{children:"This is useful for capital distributions and corporate ballots where we need a consistent set of balances as of some specific time (or block)."}),"\n",(0,n.jsx)(s.h3,{id:"creating-a-checkpoint",children:"Creating a checkpoint"}),"\n",(0,n.jsx)(s.p,{children:"There are two ways to create a checkpoint."}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:["Call the dispatchable ",(0,n.jsx)(s.code,{children:"create_checkpoint(ticker)"})," in the ",(0,n.jsx)(s.code,{children:"checkpoint"})," pallet. This creates a checkpoint for the asset of ",(0,n.jsx)(s.code,{children:"ticker"}),". The total balance is recorded instantly, and each balance held by an identity is recorded just before the next transaction to or from that identity. Since the balances of identities are not recorded instantly, we call this process ",(0,n.jsx)(s.em,{children:"lazy checkpointing"}),". A consequence of this method is that no records are made if there are no transactions."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:["Create a checkpoint schedule using the dispatchable ",(0,n.jsx)(s.code,{children:"create_schedule(ticker, schedule)"})," in the same pallet. A schedule consists of a set of ",(0,n.jsx)(s.code,{children:"Moment"})," values. Scheduled checkpoints are created automatically at times defined by the schedule but are otherwise identical in nature to manual checkpoints. Scheduling of the next checkpoint happens lazily as well, on an asset transaction or minting. If there are no such transactions by the time a checkpoint is due, it does not get rescheduled, which is fine with the scheduler since it takes into account any missed checkpoints."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"accessing-an-existing-checkpoint",children:"Accessing an existing checkpoint"}),"\n",(0,n.jsx)(s.p,{children:"The checkpoints of an asset form a sequence that is indexed starting from 1. The total balance and balances of identities are stored at these indices."}),"\n",(0,n.jsxs)(s.p,{children:["To read the total supply of ",(0,n.jsx)(s.code,{children:"ticker"})," at checkpoint index ",(0,n.jsx)(s.code,{children:"i"})," one calls the getter ",(0,n.jsx)(s.code,{children:"total_supply_at(ticker, i)"})," in the ",(0,n.jsx)(s.code,{children:"asset"})," pallet. The getter returns the value directly from runtime storage."]}),"\n",(0,n.jsxs)(s.p,{children:["To read the checkpoint balance of ",(0,n.jsx)(s.code,{children:"identity"})," one calls the function ",(0,n.jsx)(s.code,{children:"get_balance_at(ticker, identity, i)"})," in the same pallet. This function returns the checkpoint balance at ",(0,n.jsx)(s.code,{children:"i"})," by searching for the least checkpoint index greater or equal to ",(0,n.jsx)(s.code,{children:"i"})," or, if no such record exists due to the absence of transactions, the current asset balance of ",(0,n.jsx)(s.code,{children:"identity"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"The time at which a checkpoint was made is stored in a map indexed by checkpoint sequence numbers and can be read knowing the required sequence number."})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>o});var n=t(96540);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);