"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[1985],{1092:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var n=i(74848),s=i(28453);const a={title:"Architecture",description:"need to add description",subsite:"polymesh-docs/"},o=void 0,r={id:"network/architecture",title:"Architecture",description:"need to add description",source:"@site/polymesh-docs/network/architecture.mdx",sourceDirName:"network",slug:"/network/architecture",permalink:"/polymesh-documentation-site/polymesh-docs/network/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/polymesh-docs/network/architecture.mdx",tags:[],version:"current",frontMatter:{title:"Architecture",description:"need to add description",subsite:"polymesh-docs/"},sidebar:"defaultSidebar",previous:{title:"Polymesh Documentation",permalink:"/polymesh-documentation-site/polymesh-docs/"},next:{title:"Consensus",permalink:"/polymesh-documentation-site/polymesh-docs/network/consensus"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Polymesh Pillars",id:"polymesh-pillars",level:2},{value:"Identity",id:"identity",level:3},{value:"Governance",id:"governance",level:3},{value:"Confidentiality",id:"confidentiality",level:3},{value:"Compliance",id:"compliance",level:3}];function d(e){const t={a:"a",h2:"h2",h3:"h3",img:"img",p:"p",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(t.p,{children:"The Polymesh blockchain is optimised for regulated assets and markets. This is reflected in its approach to governance, security and consensus, as well as the base layer primitives provided directly by the network for asset origination and lifecycle management."}),"\n",(0,n.jsx)(t.p,{children:"Polymesh is a public, permissioned blockchain. This means that anyone can run a node and check that the rules enforced by the network are being followed by all participants, and see all the public state secured by the blockchain, but that only certain entities (called operators) are allowed to run nodes that author new blocks, and vote on the finality of other blocks."}),"\n",(0,n.jsxs)(t.p,{children:["Polymesh is built on the ",(0,n.jsx)(t.a,{href:"https://substrate.io/",children:"Substrate framework"}),", an open-source project, developed by by ",(0,n.jsx)(t.a,{href:"https://www.parity.io/",children:"Parity"}),", that provides a fully customisable, modular and extendable framework for blockchain developers."]}),"\n",(0,n.jsxs)(t.p,{children:["Polymesh has a native token, used for security and payments, ",(0,n.jsx)(t.a,{href:"../polyx/",children:"POLYX"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Polymesh provides core business logic and financial abstractions at its base layer, called primitives. These provide a rich set of embedded on-chain actions (called extrinsics) that a user can initiate, such as creating an asset, settling securities instructions or participating in on-chain governance."}),"\n",(0,n.jsxs)(t.p,{children:["Polymesh also supports Layer 2 (smart contract) logic, allowing network users to extend and leverage the base layer primitives to build on-chain financial and identity based protocols. Polymesh smart contracts compile to ",(0,n.jsx)(t.a,{href:"https://webassembly.org/",children:"WebAssembly (Wasm)"}),". Using Wasm expands the family of languages available to smart contract developers to include Rust, C/C++, C#, Typescript, Haxe amd Kotlin. As well as allows for the use of standard development tools. For Polymesh we recommend the use of ",(0,n.jsx)(t.a,{href:"https://ink.substrate.io/",children:"ink!"}),", which is a subset of Rust specifically designed by Parity for Substrate based chains. Ink! offers significantly greater performance and safety when compared with other programming languages such as Solidity."]}),"\n",(0,n.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Architecture Diagram",src:i(42650).A+"",width:"1547",height:"2563"})}),"\n",(0,n.jsx)(t.h2,{id:"polymesh-pillars",children:"Polymesh Pillars"}),"\n",(0,n.jsx)(t.p,{children:"Polymesh is tailored to the needs of regulated assets and global capital markets. This approach is guided by the four key pillars of Polymesh - Identity, Governance, Confidentiality and Compliance."}),"\n",(0,n.jsx)(t.h3,{id:"identity",children:"Identity"}),"\n",(0,n.jsx)(t.p,{children:"Identity is at the core of Polymesh. Polymesh implements a federated root of trust via permissioned Customer Due Diligence service providers. Every transaction in Polymesh is associated with an identity."}),"\n",(0,n.jsx)(t.p,{children:"Identities provide attestation and key management. All users must act through an on-chain identity when interacting with Polymesh. Identities are referenced through DIDs (decentralised identifiers)."}),"\n",(0,n.jsx)(t.p,{children:"Identity attestations allow asset issuers to enforce compliance on-chain in real-time as assets are issued, traded and settled between different parties."}),"\n",(0,n.jsx)(t.p,{children:"Identity key management allows users and organisations to flexibly manage their on-chain identities via primary and secondary keys and delegate asset management to other identities via external agent functionality."}),"\n",(0,n.jsx)(t.p,{children:"An entity (a real world individual or organisation) can have multiple on-chain identities, allowing them to keep their overall positions confidential."}),"\n",(0,n.jsx)(t.h3,{id:"governance",children:"Governance"}),"\n",(0,n.jsx)(t.p,{children:"Governance allows the chain to grow and develop. Polymesh has a sophisticated governance mechanism that combines signals from the broader community with technical experts (committees) and a governing council for actioning proposals. Polymesh Improvement Proposals (PIPs) can be proposed by any network user, and possible PIPs include network upgrades, setting the parameters of the network related to consensus and security and many other actions."}),"\n",(0,n.jsx)(t.p,{children:"The Polymesh governance system is designed to further decentralise over time."}),"\n",(0,n.jsx)(t.h3,{id:"confidentiality",children:"Confidentiality"}),"\n",(0,n.jsxs)(t.p,{children:["Confidentiality allows Polymesh users to maintain privacy over certain aspects of their securities transactions. The MERCAT protocol was designed to allow confidentiality within asset transfers using homomorphic encryption and zero-knowledge proofs. In future releases we will be integrating confidential assets into Polymesh, based on the ",(0,n.jsx)(t.a,{href:"https://info.polymesh.network/hubfs/Files/MERCAT-white-paper.pdf",children:"MERCAT"})," protocol. There is also ongoing research on how to improve and update confidentiality in Polymesh to support the full spectrum of confidentiality and securities use-cases."]}),"\n",(0,n.jsx)(t.h3,{id:"compliance",children:"Compliance"}),"\n",(0,n.jsx)(t.p,{children:"Polymesh facilitates claim based compliance directly in its base layer. Asset issuers can set flexible and extendable rules relating to the claims that their investors are required to have attached to their identity in order to either send or receive the asset. These rules can be combined to create complex transfer restrictions that are tailored to the assets specific type, jurisdiction and regulatory regime."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},42650:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/Polymesh_Architecture-6095d6d4ee4fb5e727000ab01764388e.png"},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(96540);const s={},a=n.createContext(s);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);