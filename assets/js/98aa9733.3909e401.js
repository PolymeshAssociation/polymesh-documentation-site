"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[57304],{73304:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"core-concepts/identity/advanced/authorizations","title":"Authorizations","description":"Authorization Framework","source":"@site/docs/200-core-concepts/030-identity/030-advanced/035-authorizations.md","sourceDirName":"200-core-concepts/030-identity/030-advanced","slug":"/authorizations","permalink":"/polymesh-documentation-site/authorizations","draft":false,"unlisted":false,"editUrl":"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/docs/200-core-concepts/030-identity/030-advanced/035-authorizations.md","tags":[{"inline":true,"label":"compliance","permalink":"/polymesh-documentation-site/tags/compliance"},{"inline":true,"label":"authorizations","permalink":"/polymesh-documentation-site/tags/authorizations"}],"version":"current","sidebarPosition":35,"frontMatter":{"title":"Authorizations","description":"Authorization Framework","id":"authorizations","slug":"/authorizations","sidebar_label":"Authorizations","tags":["compliance","authorizations"]},"sidebar":"docs","previous":{"title":"Multisigs","permalink":"/polymesh-documentation-site/identity/advanced/multisig"},"next":{"title":"Child Identities","permalink":"/polymesh-documentation-site/identity/advanced/child"}}');var o=i(74848),a=i(28453);const r={title:"Authorizations",description:"Authorization Framework",id:"authorizations",slug:"/authorizations",sidebar_label:"Authorizations",tags:["compliance","authorizations"]},s=void 0,c={},d=[{value:"Overview",id:"overview",level:2},{value:"Authorisation Types",id:"authorisation-types",level:2},{value:"Payment for Authorisation",id:"payment-for-authorisation",level:2}];function h(t){const e={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"In many places in Polymesh two identities, or a key and an identity, need to invite each other to have certain types of permission or access."}),"\n",(0,o.jsx)(e.p,{children:"For example, an identity may want to invite a key to join its identity as a secondary key."}),"\n",(0,o.jsx)(e.p,{children:"Authorisations in Polymesh allow an identity to invite another identity or key to take some privileged action."}),"\n",(0,o.jsx)(e.p,{children:"An identity or key can view any authorisations that they may have pending, and can approve or reject each of these authorisations."}),"\n",(0,o.jsx)(e.h2,{id:"authorisation-types",children:"Authorisation Types"}),"\n",(0,o.jsx)(e.p,{children:"There are various types of authorisations that Polymesh allows:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rust",children:"pub enum AuthorizationData<AccountId> {\n    /// CDD provider's attestation to change primary key\n    AttestPrimaryKeyRotation(IdentityId),\n    /// Authorization to change primary key\n    RotatePrimaryKey,\n    /// Authorization to transfer a ticker\n    /// Must be issued by the current owner of the ticker\n    TransferTicker(Ticker),\n    /// Add a signer to multisig\n    /// Must be issued to the identity that created the ms (and therefore owns it permanently)\n    AddMultiSigSigner(AccountId),\n    /// Authorization to transfer a token's ownership\n    /// Must be issued by the current owner of the asset\n    TransferAssetOwnership(Ticker),\n    /// Authorization to join an Identity\n    /// Must be issued by the identity which is being joined\n    JoinIdentity(Permissions),\n    /// Authorization to take custody of a portfolio\n    PortfolioCustody(PortfolioId),\n    /// Authorization to become an agent of the `Ticker` with the `AgentGroup`.\n    BecomeAgent(Ticker, AgentGroup),\n    /// Add Relayer paying key to user key\n    /// Must be issued by the paying key.\n    /// `AddRelayerPayingKey(user_key, paying_key, polyx_limit)`\n    AddRelayerPayingKey(AccountId, AccountId, Balance),\n    /// Authorization to change primary key and leave it as a secondary key\n    /// with the given permissions.\n    RotatePrimaryKeyToSecondary(Permissions),\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"Each of these authorisations are issued by an identity, but take different parameters depending on the type of action taking place."}),"\n",(0,o.jsx)(e.h2,{id:"payment-for-authorisation",children:"Payment for Authorisation"}),"\n",(0,o.jsx)(e.p,{children:"In some cases it may not be possible for the approver (or rejector) of an authorisation to pay for the transaction to do so. When a key is joining a new identity, it may not have any POLYX funds to pay for the transaction, and cannot receive POLYX as it is not yet associated with an identity (with a valid CDD claim)."}),"\n",(0,o.jsx)(e.p,{children:"When a multisig signer is proposing or approving a multisig transaction it may similarly not have POLYX (a multisig signer cannot receive POLYX as it is not directly connected to an identity)."}),"\n",(0,o.jsx)(e.p,{children:"So for the certain types of authorisation below, the transaction is paid for by the issuer of the authorisation, in particular the primary key of the identity that issued the authorisation."}),"\n",(0,o.jsx)(e.p,{children:"Authorisations types where the authorisation issuer pays are:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rust",children:"    AcceptMultiSigSigner,\n    AcceptRelayerPayingKey,\n    AcceptIdentitySecondary,\n    AcceptIdentityPrimary,\n    RotatePrimaryToSecondary,\n    /// Matches any call to `remove_authorization`,\n    /// where the authorization is available for `auth.authorized_by` payer redirection.\n    RemoveAuthorization,\n"})})]})}function u(t={}){const{wrapper:e}={...(0,a.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(h,{...t})}):h(t)}},28453:(t,e,i)=>{i.d(e,{R:()=>r,x:()=>s});var n=i(96540);const o={},a=n.createContext(o);function r(t){const e=n.useContext(a);return n.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:r(t.components),n.createElement(a.Provider,{value:e},t.children)}}}]);