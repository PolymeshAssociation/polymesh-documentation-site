"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[95956],{19429:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-concepts/corporate-actions/checkpoint-management","title":"Checkpoint Management","description":"Create and manage snapshots of asset holder balances at specific points in time","source":"@site/docs/200-core-concepts/070-corporate-actions/010-checkpoints.md","sourceDirName":"200-core-concepts/070-corporate-actions","slug":"/corporate-actions/checkpoints","permalink":"/polymesh-documentation-site/corporate-actions/checkpoints","draft":false,"unlisted":false,"editUrl":"https://github.com/PolymeshAssociation/polymesh-documentation-site/edit/develop/docs/200-core-concepts/070-corporate-actions/010-checkpoints.md","tags":[{"inline":true,"label":"corporate actions","permalink":"/polymesh-documentation-site/tags/corporate-actions"},{"inline":true,"label":"checkpoints","permalink":"/polymesh-documentation-site/tags/checkpoints"}],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Checkpoint Management","description":"Create and manage snapshots of asset holder balances at specific points in time","id":"checkpoint-management","slug":"/corporate-actions/checkpoints","sidebar_label":"Checkpoint Management","tags":["corporate actions","checkpoints"]},"sidebar":"docs","previous":{"title":"Corporate Actions","permalink":"/polymesh-documentation-site/corporate-actions"},"next":{"title":"Dividend Distribution","permalink":"/polymesh-documentation-site/corporate-actions/dividends"}}');var c=i(74848),s=i(28453);const a={title:"Checkpoint Management",description:"Create and manage snapshots of asset holder balances at specific points in time",id:"checkpoint-management",slug:"/corporate-actions/checkpoints",sidebar_label:"Checkpoint Management",tags:["corporate actions","checkpoints"]},o=void 0,r={},l=[{value:"Overview",id:"overview",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Balance Recording",id:"balance-recording",level:3},{value:"Lazy Updates",id:"lazy-updates",level:3},{value:"Creating Checkpoints",id:"creating-checkpoints",level:2},{value:"1. Manual Checkpoints",id:"1-manual-checkpoints",level:3},{value:"2. Scheduled Checkpoints",id:"2-scheduled-checkpoints",level:3},{value:"Accessing Checkpoint Data",id:"accessing-checkpoint-data",level:2},{value:"Query Total Supply",id:"query-total-supply",level:3},{value:"Query Identity Balance",id:"query-identity-balance",level:3},{value:"Query Checkpoint Creation Time",id:"query-checkpoint-creation-time",level:3},{value:"Best Practices",id:"best-practices",level:2}];function h(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,c.jsx)(n.p,{children:"An asset checkpoint is a snapshot of all holder balances for a specific asset at a particular point in time. Checkpoints are essential for many corporate actions and compliance activities, providing a verifiable record of asset ownership that can be referenced for:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Corporate Actions"}),": Support key events like dividend distributions and voting"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Regulatory Reporting"}),": Generate point-in-time records for compliance requirements"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Ownership Analysis"}),": Track historical ownership patterns and changes"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Income Distribution"}),": Process payments based on ownership at specific dates"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Governance"}),": Enable voting weight calculations and participation tracking"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,c.jsx)(n.h3,{id:"balance-recording",children:"Balance Recording"}),"\n",(0,c.jsx)(n.p,{children:"Checkpoints track two types of information:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Total Supply"}),": The total amount of the asset in circulation"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Individual Balances"}),": The amount held by each identity"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"lazy-updates",children:"Lazy Updates"}),"\n",(0,c.jsx)(n.p,{children:"Checkpoints behave slightly differently depending on the checkpoint type:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Manual Checkpoints"}),":"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Total supply is recorded immediately when the checkpoint is created"}),"\n",(0,c.jsx)(n.li,{children:"Individual balances are recorded lazily when they first change after the checkpoint"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Scheduled Checkpoints"}),":"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"The checkpoint only materializes when a balance-modifying transaction occurs at or after the scheduled time"}),"\n",(0,c.jsxs)(n.li,{children:['If no balance-modifying transaction occurs, the checkpoint never materializes on chain but remains as "pending" under the ',(0,c.jsx)(n.code,{children:"checkpoint::ScheduledCheckpoints"})," chain storage entry"]}),"\n",(0,c.jsxs)(n.li,{children:["When a checkpoint materializes:","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"The total supply at that moment is recorded. If the transaction that triggered the checkpoint creation was issuing or redeeming an asset, the total supply is recorded before the change, to reflect the supply at the time of the checkpoint."}),"\n",(0,c.jsx)(n.li,{children:"Individual balances begin being recorded lazily as they change"}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.li,{children:"For unmaterialized checkpoints, current balances are considered correct for that checkpoint"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"This approach ensures accurate recording while optimizing storage costs."}),"\n",(0,c.jsx)(n.h2,{id:"creating-checkpoints",children:"Creating Checkpoints"}),"\n",(0,c.jsx)(n.p,{children:"There are two methods for creating checkpoints:"}),"\n",(0,c.jsx)(n.h3,{id:"1-manual-checkpoints",children:"1. Manual Checkpoints"}),"\n",(0,c.jsxs)(n.p,{children:["Individual checkpoints can be created immediately using ",(0,c.jsx)(n.code,{children:"asset::create_checkpoint"}),". These are useful for:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"One-off corporate actions"}),"\n",(0,c.jsx)(n.li,{children:"Ad-hoc reporting requirements"}),"\n",(0,c.jsx)(n.li,{children:"Unscheduled distributions"}),"\n",(0,c.jsx)(n.li,{children:"Emergency or compliance-driven balance snapshots"}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"2-scheduled-checkpoints",children:"2. Scheduled Checkpoints"}),"\n",(0,c.jsxs)(n.p,{children:["Scheduled checkpoints are created by providing an array of future timestamps using ",(0,c.jsx)(n.code,{children:"asset::create_schedule"}),". The schedule consists of:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"A sorted array of timestamps defining when checkpoints should be created"}),"\n",(0,c.jsx)(n.li,{children:"Each timestamp specified in milliseconds since Unix epoch"}),"\n",(0,c.jsx)(n.li,{children:"All timestamps must be in the future at creation time"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"A scheduled checkpoint materializes when the following criteria are met:"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"The scheduled timestamp has been reached"}),"\n",(0,c.jsx)(n.li,{children:"Any action that modifies a user's balance occurs (transfer, mint, burn)"}),"\n",(0,c.jsx)(n.li,{children:"No checkpoint has been created yet for that scheduled time"}),"\n"]}),"\n",(0,c.jsx)(n.admonition,{type:"note",children:(0,c.jsx)(n.p,{children:"If multiple scheduled checkpoints have passed their timestamp when a balance-modifying action occurs, all of them will be materialized in order. This catch-up mechanism ensures no scheduled checkpoints are missed."})}),"\n",(0,c.jsxs)(n.admonition,{type:"note",children:[(0,c.jsx)(n.p,{children:"Once created, schedule timestamps cannot be modified, the schedule can only be removed. A new schedule must be created if changes are needed."}),(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"asset::remove_schedule"})," removes an existing checkpoint schedule."]})]}),"\n",(0,c.jsx)(n.h2,{id:"accessing-checkpoint-data",children:"Accessing Checkpoint Data"}),"\n",(0,c.jsx)(n.p,{children:"To determine balances at a checkpoint, you need to query the available storage maps."}),"\n",(0,c.jsx)(n.h3,{id:"query-total-supply",children:"Query Total Supply"}),"\n",(0,c.jsxs)(n.p,{children:["The total supply at a checkpoint reflects the supply when the checkpoint was created. The chain storage ",(0,c.jsx)(n.code,{children:"checkpoint::TotalSupply"})," when provided with the assetId and checkpoint ID returns the total supply at that checkpoint."]}),"\n",(0,c.jsx)(n.h3,{id:"query-identity-balance",children:"Query Identity Balance"}),"\n",(0,c.jsx)(n.p,{children:"An identity's balance at a specific checkpoint is determined as follows:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["If the identity has had any balance changes after the checkpoint, the ",(0,c.jsx)(n.code,{children:"checkpoint::BalanceUpdates"})," will include a checkpoint entry greater than or equal to the checkpoint of interest. Query ",(0,c.jsx)(n.code,{children:"checkpoint::Balance"})," for the nearest checkpoint greater than or equal to the required checkpoint."]}),"\n",(0,c.jsxs)(n.li,{children:["If no balance changes occurred after the checkpoint there will be no checkpoint entry in the ",(0,c.jsx)(n.code,{children:"checkpoint::BalanceUpdates"})," storage greater than or equal to the checkpoint of interest and you should use their current balance from ",(0,c.jsx)(n.code,{children:"asset::BalanceOf"})]}),"\n"]}),"\n",(0,c.jsxs)(n.admonition,{title:"Important",type:"note",children:[(0,c.jsx)(n.p,{children:"Checkpoints are numbered sequentially starting from 1. This sequential numbering is important when querying checkpoint data, as you'll need to use these checkpoint IDs to access the relevant data."}),(0,c.jsx)(n.p,{children:"The lazy update mechanism means balance history is only recorded when changes occur. When querying historical balances, you must account for whether balance updates exist for that checkpoint."})]}),"\n",(0,c.jsx)(n.h3,{id:"query-checkpoint-creation-time",children:"Query Checkpoint Creation Time"}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"checkpoint::Timestamp"})," storage map provides the timestamp associated with a checkpoint, which can be used for:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Verification of checkpoint timing"}),"\n",(0,c.jsx)(n.li,{children:"Determining if a scheduled checkpoint was materialized"}),"\n",(0,c.jsx)(n.li,{children:"Auditing and reporting purposes"}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,c.jsx)(n.p,{children:"When implementing checkpoints:"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Schedule Planning"}),":"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Plan checkpoint timestamps carefully as they cannot be modified once scheduled"}),"\n",(0,c.jsx)(n.li,{children:"Consider timezone implications when setting timestamps"}),"\n",(0,c.jsx)(n.li,{children:"Account for any relevant business calendar requirements"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Performance Optimization"}),":"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Understand that storage costs are optimized through lazy updates"}),"\n",(0,c.jsx)(n.li,{children:"Consider the frequency of checkpoints needed"}),"\n",(0,c.jsx)(n.li,{children:"Remember that each scheduled checkpoint consumes chain resources"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Data Management"}),":"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Monitor checkpoint creation success"}),"\n",(0,c.jsx)(n.li,{children:"Maintain schedule IDs for management"}),"\n",(0,c.jsx)(n.li,{children:"Remove schedules if they are no longer required"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.admonition,{type:"note",children:(0,c.jsx)(n.p,{children:"Checkpoints are immutable once created. Ensure timing and asset selection are correct before creation."})}),"\n",(0,c.jsx)(n.admonition,{type:"tip",children:(0,c.jsx)(n.p,{children:"When querying historical balances, remember that the lazy update mechanism means some checkpoint balances may be the current holdings rather than historical positions if no transactions occurred after the checkpoint."})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const c={},s=t.createContext(c);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);