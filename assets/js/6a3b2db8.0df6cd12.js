"use strict";(self.webpackChunkpolymesh_developer_documentation=self.webpackChunkpolymesh_developer_documentation||[]).push([[94065],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>p});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(r),u=o,p=m["".concat(l,".").concat(u)]||m[u]||h[u]||i;return r?n.createElement(p,a(a({ref:t},d),{},{components:r})):n.createElement(p,a({ref:t},d))}));function p(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=r[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},57100:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(87462),o=(r(67294),r(3905));const i={title:"POLY to POLYX Bridge",description:"",subsite:"polymesh-docs"},a=void 0,s={unversionedId:"network/bridge",id:"network/bridge",title:"POLY to POLYX Bridge",description:"",source:"@site/polymesh-docs/network/bridge.mdx",sourceDirName:"network",slug:"/network/bridge",permalink:"/polymesh-documentation-site/polymesh-docs/network/bridge",draft:!1,tags:[],version:"current",frontMatter:{title:"POLY to POLYX Bridge",description:"",subsite:"polymesh-docs"},sidebar:"defaultSidebar",previous:{title:"Architecture",permalink:"/polymesh-documentation-site/polymesh-docs/network/architecture"},next:{title:"Consensus",permalink:"/polymesh-documentation-site/polymesh-docs/network/consensus"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Ethereum Locking Contract",id:"ethereum-locking-contract",level:2},{value:"Relayer Middleware",id:"relayer-middleware",level:2},{value:"Polymesh Runtime Module",id:"polymesh-runtime-module",level:2},{value:"State Diagram",id:"state-diagram",level:2}],d={toc:c};function m(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"The POLY to POLYX bridge allows ERC20 POLY tokens issued on the Ethereum Mainnet, to be bridged on a 1-1 basis to Polymesh as POLYX native tokens."),(0,o.kt)("p",null,"Carrying the tokens over follows the standard ",(0,o.kt)("em",{parentName:"p"},"lock and mint")," process. First, Ethereum tokens are locked permanently by an Ethereum smart contract. Then, native tokens are minted on the Polymesh side."),(0,o.kt)("p",null,"The bridge is a distributed system made up of the Ethereum smart contract, off-chain relay middleware and a dedicated Polymesh ",(0,o.kt)("a",{parentName:"p",href:"https://docs.polymesh.live/pallet_bridge/index.html"},"runtime module"),"."),(0,o.kt)("h2",{id:"ethereum-locking-contract"},"Ethereum Locking Contract"),(0,o.kt)("p",null,"Any POLY holder can lock their POLY. The smart contract only locks POLY and rejects any other tokens. In order to be locked, the amount must be greater than 1 POLY. There is no maximum on how much POLY can be locked. The granularity for locked POLY is restricted to that of the Polymesh chain, that is, 6 digits after the decimal period."),(0,o.kt)("p",null,"The user provides their Polymesh key when locking POLY, however the contract does not check the validity of that key. Once the POLY is locked, the contract emits an event with the locked amount, the destination Polymesh key and the lock transaction hash."),(0,o.kt)("h2",{id:"relayer-middleware"},"Relayer Middleware"),(0,o.kt)("p",null,"Lock events emitted by the Ethereum POLY locker contract are listened to by ",(0,o.kt)("em",{parentName:"p"},"relayer")," processes and verified by a sufficient amount of block confirmations. Each relayer process extracts Ethereum lock transactions from the received events and requests a connected ",(0,o.kt)("em",{parentName:"p"},"signer")," process to sign those transactions before proposing thus signed transactions to the on-chain Polymesh bridge multisig, more details below."),(0,o.kt)("p",null,"Each signer has a Polymesh key which is registered in the bridge multisig wallet. This way the signers act as multisig voters. However the signers' role is only to passively sign the incoming transactions. It is the responsibility of the relayers to submit the signers' votes to the Polymesh chain."),(0,o.kt)("h2",{id:"polymesh-runtime-module"},"Polymesh Runtime Module"),(0,o.kt)("p",null,"Minting of POLYX tokens is implemented in the Polymesh runtime, in the bridge pallet. Below is the state machine diagram for the lifecycle of a bridge transaction arriving at Polymesh from the bridge relayers. There are 5 states: absent, timelocked, pending, handled and frozen. Any successful transaction makes its way from absent (start) to handled (end). The solid arrows correspond to automated transitions according to the business logic. The dashed arrows correspond to manual actions of the bridge administrator. The administrator has the ability to freeze a transaction that is still in progress. This is however an exceptional measure only to allow for the human to stay in the loop. It is supposed to be exercised only in extreme cases."),(0,o.kt)("p",null,"Relayers are members of the bridge multisig account owned by the ",(0,o.kt)("em",{parentName:"p"},"bridge controller"),", and provided a quorum agree, POLY locked on Ethereum will be bridged to Polymesh."),(0,o.kt)("p",null,"Even though there is no maximum limit of how much POLY can be bridged, the Testnet sets a limit on how much POLY is bridged per unit of time. There is going to be no such a limit on the Mainnet."),(0,o.kt)("h2",{id:"state-diagram"},"State Diagram"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"State Diagram",src:r(31519).Z,width:"1263",height:"1321"})))}m.isMDXComponent=!0},31519:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Bridge-f3915a6576c6abb0587893d063e3235f.png"}}]);